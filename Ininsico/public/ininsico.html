<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Olmec 3D - Professional Modeling Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Add this before the Spectrum CSS -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-csg-ts@1.0.3/dist/three-csg.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --primary: #6e48ff;
            /* Vibrant purple-blue */
            --primary-dark: #4a1eff;
            /* Darker purple-blue */
            --secondary: #9d50ff;
            /* Lighter purple */
            --accent: #4776ff;
            /* Blue accent */
            --bg-primary: #0a0a0a;
            --bg-secondary: #111111;
            --bg-tertiary: #1a1a1a;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --success: #4a68de;
            --warning: #fbbf24;
            --error: #ff4d4d;
            --info: #60a5fa;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #111111 50%, #0f0f23 100%);
            overflow: hidden;
            color: #ffffff;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background:
                radial-gradient(circle at 20% 80%, rgba(110, 72, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(157, 80, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(71, 118, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        /* Improved Glass Effect */
        .glass {
            background: rgba(20, 20, 20, 0.4);
            backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.3s ease;
        }

        .submenu {
            position: absolute;
            top: 100%;
            left: 0;
            min-width: 200px;
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all 0.3s ease;
            z-index: 100;
        }


        .menu-item:hover .submenu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .glass:hover {
            background: rgba(30, 30, 30, 0.5);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .glass-dark {
            background: rgba(10, 10, 10, 0.5);
            backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* Neon Effects */
        .neon-border {
            border: 1px solid var(--primary);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .neon-glow {
            box-shadow:
                0 0 20px rgba(110, 72, 255, 0.2),
                0 0 40px rgba(110, 72, 255, 0.1),
                inset 0 0 20px rgba(110, 72, 255, 0.05);
        }

        /* Animations */
        @keyframes float {

            0%,
            100% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: .8;
            }
        }

        @keyframes slideInLeft {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse-glow {

            0%,
            100% {
                box-shadow: 0 0 10px rgba(110, 72, 255, 0.5);
            }

            50% {
                box-shadow: 0 0 20px rgba(110, 72, 255, 0.8);
            }
        }

        @keyframes tool-hover {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        /* Buttons */
        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            box-shadow: 0 4px 15px rgba(58, 134, 255, 0.3);
            transition: all 0.3s ease;
            border: none;
            color: white;
            font-weight: 600;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 255, 0.4);
            animation: pulse-glow 1.5s infinite;
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--secondary) 0%, #6a2fc6 100%);
            box-shadow: 0 4px 15px rgba(131, 56, 236, 0.3);
            transition: all 0.3s ease;
            border: none;
            color: white;
            font-weight: 600;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.4);
            animation: pulse-glow 1.5s infinite;
        }

        /* Logo */
        .logo {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 800;

            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);

            transition: all 0.3s ease;
        }

        .logo:hover {
            filter: drop-shadow(0 0 15px rgba(110, 72, 255, 0.8));
        }

        /* Menu Items */
        .menu-item {
            position: relative;
            overflow: visible;
            transition: all 0.2s ease;
            pointer-events: auto;
        }

        .menu-item:hover {
            background: rgba(255, 255, 255, 0.05);
            pointer-events: auto;
        }

        /* Axis constraint buttons */
        .axis-constraint-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
        }

        .axis-constraint-btn.active {
            background: var(--primary);
            color: #111;
        }

        .axis-constraint-btn[data-axis="x"].active {
            background: #ff4d4d;
        }

        .axis-constraint-btn[data-axis="y"].active {
            background: #4dff4d;
        }

        .axis-constraint-btn[data-axis="z"].active {
            background: #4d4dff;
        }

        /* Texture buttons */
        .texture-btn {
            transition: all 0.2s ease;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .texture-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Notification types */
        .notification.info {
            border-left: 4px solid var(--secondary);
        }

        .notification.success {
            border-left: 4px solid var(--success);
        }

        .notification.warning {
            border-left: 4px solid var(--warning);
        }

        .notification.error {
            border-left: 4px solid #ff4d4d;
        }

        /* Collapsible Panel Styles */
        .panel-toggle {
            position: absolute;
            top: 50%;
            width: 16px;
            height: 48px;
            background: rgba(30, 30, 30, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
            border-radius: 4px;
        }

        .panel-toggle:hover {
            background: rgba(60, 60, 60, 0.8);
        }

        .left-panel-toggle {
            right: -16px;
            transform: translateY(-50%);
            border-left: none;
            border-radius: 0 4px 4px 0;
        }

        .right-panel-toggle {
            left: -16px;
            transform: translateY(-50%);
            border-right: none;
            border-radius: 4px 0 0 4px;
        }

        .collapsed {
            width: 0 !important;
            overflow: hidden;
            border: none;
        }

        .collapsed .panel-content {
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .panel-content {
            transition: opacity 0.3s ease;
        }

        /* Tool Buttons */
        .tool-btn {
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            animation: tool-hover 0.5s ease;
        }

        /* Update status bar */
        .status-bar {
            border-top: 1px solid rgba(110, 72, 255, 0.3);
        }

        /* Inputs */
        .property-input {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            color: white;
        }

        .property-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(51, 0, 255, 0.3);
            outline: none;
        }

        /* Scrollbar */
        .scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .scrollbar::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        .scrollbar::-webkit-scrollbar-thumb {
            background: rgba(110, 72, 255, 0.3);
            border-radius: 3px;
        }

        .scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(110, 72, 255, 0.5);
        }

        /* Viewport */
        .viewport {
            background: radial-gradient(ellipse at center, #1a1a1a 0%, #0a0a0a 100%);
            position: relative;
        }

        /* Welcome Screen */
        .welcome-screen {
            background: rgba(10, 10, 10, 0.7);
            backdrop-filter: blur(10px);
            transition: all 0.5s ease;
        }

        /* Sculpting Tools */
        .sculpt-tool {
            transition: all 0.3s ease;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        /* Update active tool buttons */
        .tool-btn.active {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%) !important;
            box-shadow: 0 0 20px rgba(110, 72, 255, 0.5) !important;
        }

        /* Improved Panel Headers */
        .panel-header {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.5) 0%, rgba(17, 17, 17, 0.5) 100%);
            border-bottom: 1px solid rgba(110, 72, 255, 0.3);
            padding: 12px 16px;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s ease;
        }

        .panel-header:hover {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7) 0%, rgba(17, 17, 17, 0.7) 100%);
        }

        /* Three.js canvas styling */
        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            outline: none;
        }

        /* Context Menu */
        .context-menu {
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(110, 72, 255, 0.3);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            min-width: 200px;
            z-index: 1000;
            transform-origin: top left;
            animation: fadeIn 0.2s ease-out;
        }

        .context-item {
            transition: all 0.2s ease;
        }

        .context-item:hover {
            background: rgba(0, 255, 136, 0.1);
        }


        /* Tab System */
        .tab-button {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tab-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .tab-button.active {
            background: rgba(252, 251, 255, 0.2);
            color: white;
            border-bottom: 2px solid var(--primary);
        }

        /* Toolbar */
        .toolbar-section {
            display: flex;
            align-items: center;
            padding: 0 12px;
            border-right: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* Update scene items */
        .scene-item:hover {
            background: rgba(110, 72, 255, 0.1);
        }

        .scene-item.selected {
            background: rgba(110, 72, 255, 0.2);
            border-left: 3px solid var(--primary);
        }

        .scene-item.selected {
            background: rgba(0, 255, 136, 0.2);
            border-left: 3px solid var(--primary);
        }

        /* Sculpting Panel */
        .sculpting-panel {
            display: none;
        }

        /* Update sculpt tools */
        .sculpt-tool:hover {
            background: rgba(110, 72, 255, 0.1);
        }

        .sculpt-tool.active {
            background: rgba(110, 72, 255, 0.2);
            border: 1px solid var(--primary);
            box-shadow: 0 0 15px rgba(110, 72, 255, 0.3);
        }

        /* Animation Classes */
        .floating-animation {
            animation: float 3s ease-in-out infinite;
        }

        .pulse-animation {
            animation: pulse 2s ease infinite;
        }

        .slide-in-left {
            animation: slideInLeft 0.5s ease-out;
        }

        .slide-in-right {
            animation: slideInRight 0.5s ease-out;
        }

        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }

        /* Responsive Adjustments */
        @media (max-width: 1200px) {
            .sidebar {
                width: 280px;
            }
        }

        /* Custom Grid */
        .grid-pattern {
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
        }

        /* Progress Bar */
        .progress-bar {
            height: 4px;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Notification */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }
    </style>
</head>

<body>
    <div id="app" class="h-screen flex flex-col">
        <!-- Header -->
        <header class="h-16 glass-dark border-b border-gray-800/50 flex items-center px-6 relative z-50 slide-in-left">
            <div class="text-2xl font-black mr-8 ">
                Olmec
            </div>

            <nav class="flex space-x-1">
                <div class="menu-item relative group">
                    <div class="px-4 py-2 rounded-lg cursor-pointer">
                        <span class="text-sm font-medium">File</span>
                    </div>
                    <div
                        class="submenu absolute top-full left-0 mt-2 min-w-[200px] rounded-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform translate-y-2 group-hover:translate-y-0 glass-dark">
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-t-lg" id="new-project-btn">
                            <i class="fas fa-plus w-4 mr-3"></i>New Project
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer" id="open-project-btn">
                            <i class="fas fa-folder-open w-4 mr-3"></i>Open...
                        </div>
                        <div class="h-px bg-gray-700 mx-2"></div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer" id="import-btn">
                            <i class="fas fa-download w-4 mr-3"></i>Import
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-b-lg" id="export-btn">
                            <i class="fas fa-upload w-4 mr-3"></i>Export
                        </div>
                    </div>
                </div>

                <div class="menu-item relative group">
                    <div class="px-4 py-2 rounded-lg cursor-pointer">
                        <span class="text-sm font-medium">Edit</span>
                    </div>
                    <div
                        class="submenu absolute top-full left-0 mt-2 min-w-[200px] rounded-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform translate-y-2 group-hover:translate-y-0 glass-dark">
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-t-lg" id="undo-btn">
                            <i class="fas fa-undo w-4 mr-3"></i>Undo
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer" id="redo-btn">
                            <i class="fas fa-redo w-4 mr-3"></i>Redo
                        </div>
                        <div class="h-px bg-gray-700 mx-2"></div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer" id="duplicate-btn">
                            <i class="fas fa-clone w-4 mr-3"></i>Duplicate
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-b-lg" id="delete-btn">
                            <i class="fas fa-trash w-4 mr-3"></i>Delete
                        </div>
                    </div>
                </div>

                <div class="menu-item relative group">
                    <div class="px-4 py-2 rounded-lg cursor-pointer">
                        <span class="text-sm font-medium">Add</span>
                    </div>
                    <div
                        class="submenu absolute top-full left-0 mt-2 min-w-[200px] rounded-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform translate-y-2 group-hover:translate-y-0 glass-dark">
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-t-lg" id="add-mesh-btn">
                            <i class="fas fa-cube w-4 mr-3"></i>Mesh
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer" id="add-light-btn">
                            <i class="fas fa-lightbulb w-4 mr-3"></i>Light
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-b-lg" id="add-camera-btn">
                            <i class="fas fa-camera w-4 mr-3"></i>Camera
                        </div>
                    </div>
                </div>

                <div class="menu-item relative group">
                    <div class="px-4 py-2 rounded-lg cursor-pointer">
                        <span class="text-sm font-medium">Sculpt</span>
                    </div>
                    <div
                        class="submenu absolute top-full left-0 mt-2 min-w-[200px] rounded-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform translate-y-2 group-hover:translate-y-0 glass-dark">
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-t-lg" id="sculpt-draw-btn">
                            <i class="fas fa-paint-brush w-4 mr-3"></i>Draw
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer" id="sculpt-smooth-btn">
                            <i class="fas fa-hand-holding-water w-4 mr-3"></i>Smooth
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer" id="sculpt-flatten-btn">
                            <i class="fas fa-ruler-combined w-4 mr-3"></i>Flatten
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-b-lg" id="sculpt-inflate-btn">
                            <i class="fas fa-expand w-4 mr-3"></i>Inflate
                        </div>
                    </div>
                </div>
            </nav>

            <div class="ml-auto flex items-center space-x-4">
                <div class="flex items-center space-x-2">
                    <div class="w-2 h-2 bg-primary-400 rounded-full pulse-animation"></div>
                    <span class="text-sm text-gray-400 code-font">ONLINE</span>
                </div>
                <button class="btn-primary px-4 py-2 rounded-lg text-sm font-medium" id="export-scene-btn">
                    <i class="fas fa-cloud-upload-alt mr-2"></i>Export
                </button>
            </div>
        </header>

        <!-- Progress Bar -->
        <div class="progress-bar" id="progress-bar"></div>

        <!-- Main Container -->
        <div class="flex-1 flex overflow-hidden">
            <!-- Left Sidebar -->
            <aside class="w-80 glass-dark border-r border-gray-800/50 overflow-y-auto scrollbar slide-in-left relative">
                <!-- Add toggle button -->
                <div class="panel-toggle left-panel-toggle" id="left-panel-toggle">
                    <i class="fas fa-chevron-left"></i>
                </div>
                <div class="panel-content h-full">
                    <!-- Tab Navigation -->
                    <div class="flex border-bv  border-gray-800/50">
                        <button class="tab-button active" data-tab="create">Create</button>
                        <button class="tab-button" data-tab="sculpt">Sculpt</button>
                        <button class="tab-button" data-tab="scene">Scene</button>
                    </div>

                    <!-- Create Panel -->
                    <div class="p-6 fade-in" id="create-panel">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-plus-circle mr-3 text-green-400"></i>
                                Create Objects
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg">
                            <div class="grid grid-cols-3 gap-3">
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="box">
                                    <i class="fas fa-cube text-2xl text-green-400"></i>
                                    <span class="text-xs font-medium">Cube</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="sphere">
                                    <i class="fas fa-globe text-2xl text-blue-400"></i>
                                    <span class="text-xs font-medium">Sphere</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="cylinder">
                                    <i class="fas fa-database text-2xl text-purple-400"></i>
                                    <span class="text-xs font-medium">Cylinder</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="cone">
                                    <i class="fas fa-concierge-bell text-2xl text-yellow-400"></i>
                                    <span class="text-xs font-medium">Cone</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="torus">
                                    <i class="fas fa-ring text-2xl text-pink-400"></i>
                                    <span class="text-xs font-medium">Torus</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="plane">
                                    <i class="fas fa-square text-2xl text-gray-400"></i>
                                    <span class="text-xs font-medium">Plane</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="extrude">
                                    <i class="fas fa-vector-square text-2xl text-blue-400"></i>
                                    <span class="text-xs font-medium">Extrude</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="bevel">
                                    <i class="fas fa-border-style text-2xl text-purple-400"></i>
                                    <span class="text-xs font-medium">Bevel</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="boolean">
                                    <i class="fas fa-shapes text-2xl text-yellow-400"></i>
                                    <span class="text-xs font-medium">Boolean</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Sculpting Panel -->
                    <!-- Update in the HTML -->
                    <div class="p-6 fade-in sculpting-panel" id="sculpt-panel">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-sculpture mr-3 text-purple-400"></i>
                                Sculpting Tools
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg">
                            <div class="grid grid-cols-4 gap-2 mb-4">
                                <!-- Updated tool buttons with better icons -->
                                <div class="sculpt-tool" data-tool="draw" title="Draw">
                                    <i class="fas fa-paint-brush text-xl text-green-400 mb-1"></i>
                                    <span class="text-xs">Draw</span>
                                </div>
                                <div class="sculpt-tool" data-tool="smooth" title="Smooth">
                                    <i class="fas fa-brush text-xl text-blue-400 mb-1"></i>
                                    <span class="text-xs">Smooth</span>
                                </div>
                                <div class="sculpt-tool" data-tool="flatten" title="Flatten">
                                    <i class="fas fa-ruler-combined text-xl text-yellow-400 mb-1"></i>
                                    <span class="text-xs">Flatten</span>
                                </div>
                                <div class="sculpt-tool" data-tool="inflate" title="Inflate">
                                    <i class="fas fa-expand text-xl text-pink-400 mb-1"></i>
                                    <span class="text-xs">Inflate</span>
                                </div>
                                <div class="sculpt-tool" data-tool="pinch" title="Pinch">
                                    <i class="fas fa-hand-paper text-xl text-red-400 mb-1"></i>
                                    <span class="text-xs">Pinch</span>
                                </div>
                                <div class="sculpt-tool" data-tool="grab" title="Grab">
                                    <i class="fas fa-hand-rock text-xl text-purple-400 mb-1"></i>
                                    <span class="text-xs">Grab</span>
                                </div>
                                <div class="sculpt-tool" data-tool="crevice" title="Crevice">
                                    <i class="fas fa-mountain text-xl text-orange-400 mb-1"></i>
                                    <span class="text-xs">Crevice</span>
                                </div>
                                <div class="sculpt-tool" data-tool="mask" title="Mask">
                                    <i class="fas fa-mask text-xl text-teal-400 mb-1"></i>
                                    <span class="text-xs">Mask</span>
                                </div>
                            </div>

                            <div class="space-y-4">
                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Brush Size</label>
                                    <div class="flex items-center space-x-2">
                                        <input type="range" min="0.01" max="2" step="0.01" value="0.5" class="w-full"
                                            id="brush-size">
                                        <span class="text-xs w-12 text-right" id="brush-size-value">0.5</span>
                                    </div>
                                </div>

                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Strength</label>
                                    <div class="flex items-center space-x-2">
                                        <input type="range" min="0.01" max="1" step="0.01" value="0.5" class="w-full"
                                            id="brush-strength">
                                        <span class="text-xs w-12 text-right" id="brush-strength-value">0.5</span>
                                    </div>
                                </div>

                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Falloff</label>
                                    <div class="flex items-center space-x-2">
                                        <input type="range" min="0" max="1" step="0.01" value="0.5" class="w-full"
                                            id="brush-falloff">
                                        <span class="text-xs w-12 text-right" id="brush-falloff-value">0.5</span>
                                    </div>
                                </div>

                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Symmetry</label>
                                    <select class="property-input w-full px-3 py-2 rounded-lg text-sm"
                                        id="brush-symmetry">
                                        <option value="none">None</option>
                                        <option value="x">X-Axis</option>
                                        <option value="y">Y-Axis</option>
                                        <option value="z">Z-Axis</option>
                                        <option value="radial">Radial</option>
                                    </select>
                                </div>

                                <div class="flex space-x-2">
                                    <button class="flex-1 btn-secondary py-2 rounded-lg text-sm" id="sculpt-undo-btn">
                                        <i class="fas fa-undo mr-1"></i> Undo
                                    </button>
                                    <button class="flex-1 btn-secondary py-2 rounded-lg text-sm" id="sculpt-redo-btn">
                                        <i class="fas fa-redo mr-1"></i> Redo
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Scene Hierarchy Panel -->
                    <div class="p-6 fade-in sculpting-panel" id="scene-panel">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-sitemap mr-3 text-blue-400"></i>
                                Scene Hierarchy
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg min-h-[200px]">
                            <ul id="scene-hierarchy" class="space-y-1"></ul>
                            <div class="text-center text-gray-500 text-sm mt-8" id="empty-scene-message">
                                <i class="fas fa-layer-group text-2xl mb-2 block"></i>
                                No objects in scene
                            </div>
                        </div>
                    </div>
                </div>

            </aside>

            <!-- Main Viewport -->
            <main class="flex-1 flex flex-col">
                <!-- Toolbar -->
                <div
                    class="h-16 glass-dark border-b border-gray-800/50 flex items-center px-6 space-x-2 slide-in-right">
                    <div class="toolbar-section">
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-tool="select" id="select-tool-btn">
                            <i class="fas fa-mouse-pointer"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-tool="move" id="translate-tool-btn">
                            <i class="fas fa-arrows-alt"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-tool="rotate" id="rotate-tool-btn">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-tool="scale" id="scale-tool-btn">
                            <i class="fas fa-expand-arrows-alt"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-tool="boolean-union" id="boolean-union-btn">
                            <i class="fas fa-plus-circle"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-tool="boolean-difference" id="boolean-difference-btn">
                            <i class="fas fa-minus-circle"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-tool="boolean-intersect" id="boolean-intersect-btn">
                            <i class="fas fa-times-circle"></i>
                        </button>
                    </div>

                    <div class="toolbar-section">
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-view-mode="solid" id="solid-view-btn">
                            <i class="fas fa-cube"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-view-mode="wireframe" id="wireframe-view-btn">
                            <i class="fas fa-project-diagram"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-view-mode="material" id="material-view-btn">
                            <i class="fas fa-palette"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-view-mode="rendered" id="rendered-view-btn">
                            <i class="fas fa-eye"></i>
                        </button>
                    </div>

                    <div class="toolbar-section">
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-camera-view="front" id="front-view-btn">
                            <i class="fas fa-arrow-up"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-camera-view="side" id="side-view-btn">
                            <i class="fas fa-arrow-right"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-camera-view="top" id="top-view-btn">
                            <i class="fas fa-arrow-down"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-camera-view="perspective" id="perspective-view-btn">
                            <i class="fas fa-cube"></i>
                        </button>
                    </div>

                    <div class="ml-auto flex items-center space-x-4">
                        <div class="flex items-center space-x-2 glass px-4 py-2 rounded-lg">
                            <span class="text-sm text-gray-400">Viewport:</span>
                            <select class="bg-transparent text-sm text-white border-none outline-none"
                                id="viewport-type-select">
                                <option value="perspective">Perspective</option>
                                <option value="orthographic">Orthographic
                                <option value="orthographic">Orthographic</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- 3D Viewport -->
                <div class="flex-1 viewport relative" id="viewport">
                    <canvas id="three-canvas"></canvas>

                    <!-- Welcome screen (hidden when objects exist) -->
                    <div class="absolute inset-0 flex items-center justify-center welcome-screen" id="welcome-screen">
                        <div class="text-center">
                            <div
                                class="w-32 h-32 glass rounded-full flex items-center justify-center mb-8 mx-auto floating-animation">
                                <i class="fas fa-cube text-4xl text-green-400"></i>
                            </div>
                            <h3 class="text-2xl font-bold mb-4">Welcome to Olmec 3D</h3>
                            <p class="text-gray-400 mb-6 max-w-md">Start creating by adding objects from the left panel
                                or use the Add menu above.</p>
                            <div class="flex justify-center space-x-4">
                                <button class="btn-primary px-6 py-3 rounded-lg font-medium" id="add-cube-welcome-btn">
                                    <i class="fas fa-plus mr-2"></i>Add Cube
                                </button>
                                <button class="glass px-6 py-3 rounded-lg font-medium hover:bg-white/10"
                                    id="open-project-welcome-btn">
                                    <i class="fas fa-folder-open mr-2"></i>Open Project
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Viewport Controls -->
                    <div class="absolute top-4 right-4 flex flex-col space-y-2">
                        <div class="glass rounded-lg p-2" id="axis-helper">
                            <div class="w-16 h-16 relative">
                                <div class="absolute inset-0 border border-gray-600 rounded"></div>
                                <div class="absolute top-1 left-1/2 transform -translate-x-1/2 w-1 h-4 bg-red-400">
                                </div>
                                <div class="absolute right-1 top-1/2 transform -translate-y-1/2 w-4 h-1 bg-primary-400">
                                </div>
                                <div
                                    class="absolute bottom-1 left-1/2 transform -translate-x-1/2 w-3 h-3 border-l border-b border-blue-400">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Grid Info -->
                    <div class="absolute bottom-4 left-4 glass px-3 py-2 rounded-lg">
                        <span class="text-xs text-gray-400 code-font">Grid: 1.0 units</span>
                    </div>
                </div>
            </main>

            <!-- Right Sidebar -->
            <aside
                class="w-80 glass-dark border-l border-gray-800/50 overflow-y-auto scrollbar slide-in-right relative">

                <!-- Add toggle button -->
                <div class="panel-toggle right-panel-toggle" id="right-panel-toggle">
                    <i class="fas fa-chevron-right"></i>
                </div>
                <!-- Wrap panel content -->
                <div class="panel-content h-full">
                    <!-- Properties Panel -->
                    <!-- Add this to your properties panel section -->
                    <div class="p-6 fade-in" id="bevel-extrude-panel">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-layer-group mr-3 text-purple-400"></i>
                                Bevel & Extrude
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg">
                            <!-- Extrude Controls -->
                            <div class="mb-4">
                                <label class="block text-xs text-gray-400 mb-2">Extrude Depth</label>
                                <input type="range" min="0.1" max="5" step="0.1" value="1" class="w-full"
                                    id="extrude-depth">
                                <span class="text-xs text-gray-400" id="extrude-depth-value">1.0</span>
                            </div>

                            <!-- Bevel Controls -->
                            <div class="mb-2">
                                <label class="block text-xs text-gray-400 mb-2">Bevel Enabled</label>
                                <input type="checkbox" id="bevel-enabled" class="rounded" checked>
                            </div>

                            <div class="mb-4">
                                <label class="block text-xs text-gray-400 mb-2">Bevel Size</label>
                                <input type="range" min="0" max="1" step="0.05" value="0.1" class="w-full"
                                    id="bevel-size">
                                <span class="text-xs text-gray-400" id="bevel-size-value">0.1</span>
                            </div>

                            <div class="mb-4">
                                <label class="block text-xs text-gray-400 mb-2">Bevel Thickness</label>
                                <input type="range" min="0" max="1" step="0.05" value="0.1" class="w-full"
                                    id="bevel-thickness">
                                <span class="text-xs text-gray-400" id="bevel-thickness-value">0.1</span>
                            </div>

                            <div class="mb-4">
                                <label class="block text-xs text-gray-400 mb-2">Bevel Segments</label>
                                <input type="range" min="1" max="10" step="1" value="3" class="w-full"
                                    id="bevel-segments">
                                <span class="text-xs text-gray-400" id="bevel-segments-value">3</span>
                            </div>

                            <button class="w-full btn-primary px-4 py-2 rounded-lg text-sm font-medium"
                                id="apply-extrude-btn">
                                Apply Extrusion
                            </button>
                        </div>
                    </div>
                    <div class="p-6 fade-in">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-cog mr-3 text-blue-400"></i>
                                Properties
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg" id="properties-panel">
                            <div class="text-center text-gray-500 text-sm" id="no-selection-message">
                                <i class="fas fa-mouse-pointer text-2xl mb-2 block"></i>
                                Select an object to view properties
                            </div>
                        </div>
                    </div>

                    <!-- Transform Panel -->
                    <div class="p-6 fade-in">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-arrows-alt mr-3 text-orange-400"></i>
                                Transform
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg">
                            <!-- Transform Tabs -->
                            <div class="flex mb-4">
                                <button class="tab-button active" data-transform-tab="location">Location</button>
                                <button class="tab-button" data-transform-tab="rotation">Rotation</button>
                                <button class="tab-button" data-transform-tab="scale">Scale</button>
                            </div>

                            <!-- Transform Values -->
                            <div class="space-y-3" id="transform-values">
                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">X</label>
                                    <input type="number" value="0.000"
                                        class="property-input w-full px-3 py-2 rounded-lg text-sm code-font"
                                        data-transform-axis="x">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Y</label>
                                    <input type="number" value="0.000"
                                        class="property-input w-full px-3 py-2 rounded-lg text-sm code-font"
                                        data-transform-axis="y">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Z</label>
                                    <input type="number" value="0.000"
                                        class="property-input w-full px-3 py-2 rounded-lg text-sm code-font"
                                        data-transform-axis="z">
                                </div>
                            </div>
                            <div class="flex items-center justify-between mb-3">
                                <span class="text-sm">Snap to Grid</span>
                                <input type="checkbox" id="snap-toggle" class="rounded">
                            </div>
                            <div class="flex items-center justify-between mb-3">
                                <span class="text-sm">Snap Value</span>
                                <input type="number" value="0.25" step="0.05" min="0.05" max="1"
                                    class="property-input w-16 px-2 py-1 rounded text-sm">
                            </div>
                            <div class="flex items-center justify-between mb-3">
                                <span class="text-sm">Axis Constraints</span>
                                <div class="flex space-x-1">
                                    <button class="axis-constraint-btn px-2 py-1 rounded text-xs"
                                        data-axis="x">X</button>
                                    <button class="axis-constraint-btn px-2 py-1 rounded text-xs"
                                        data-axis="y">Y</button>
                                    <button class="axis-constraint-btn px-2 py-1 rounded text-xs"
                                        data-axis="z">Z</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Material Panel -->
                    <div class="p-6 fade-in">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-palette mr-3 text-pink-400"></i>
                                Material
                            </h3>
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-image mr-3 text-teal-400"></i>
                                Texture Maps
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg" id="material-panel">
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-xs text-gray-400 mb-2">Base Color</label>
                                    <div class="flex items-center space-x-2">
                                        <div class="flex items-center space-x-2">
                                            <input type="text" class="property-input" id="color-picker-input">
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-2">Metallic</label>
                                    <input type="range" min="0" max="1" step="0.01" value="0" class="w-full"
                                        id="metallic-slider">
                                    <span class="text-xs text-gray-400" id="metallic-value">0.00</span>
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-2">Roughness</label>
                                    <input type="range" min="0" max="1" step="0.01" value="0.5" class="w-full"
                                        id="roughness-slider">
                                    <span class="text-xs text-gray-400" id="roughness-value">0.50</span>
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-2">Diffuse Map</label>
                                    <div class="flex items-center space-x-2">
                                        <button class="texture-btn glass px-3 py-2 rounded-lg text-sm w-full text-left"
                                            id="diffuse-map-btn">
                                            <span id="diffuse-map-name">None</span>
                                        </button>
                                        <button class="glass px-2 py-2 rounded-lg text-sm" id="clear-diffuse-btn">
                                            <i class="fas fa-times"></i>
                                        </button>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-2">Normal Map</label>
                                    <div class="flex items-center space-x-2">
                                        <button class="texture-btn glass px-3 py-2 rounded-lg text-sm w-full text-left"
                                            id="normal-map-btn">
                                            <span id="normal-map-name">None</span>
                                        </button>
                                        <button class="glass px-2 py-2 rounded-lg text-sm" id="clear-normal-btn">
                                            <i class="fas fa-times"></i>
                                        </button>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-2">Roughness Map</label>
                                    <div class="flex items-center space-x-2">
                                        <button class="texture-btn glass px-3 py-2 rounded-lg text-sm w-full text-left"
                                            id="roughness-map-btn">
                                            <span id="roughness-map-name">None</span>
                                        </button>
                                        <button class="glass px-2 py-2 rounded-lg text-sm" id="clear-roughness-btn">
                                            <i class="fas fa-times"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                    </div>

                    <!-- Lighting Panel -->
                    <div class="p-6 fade-in">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-lightbulb mr-3 text-yellow-400"></i>
                                Lighting
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg">
                            <div class="space-y-3">
                                <div class="flex items-center justify-between">
                                    <span class="text-sm">Environment Light</span>
                                    <input type="checkbox" checked class="rounded" id="env-light-toggle">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-2">Intensity</label>
                                    <input type="range" min="0" max="10" step="0.1" value="1" class="w-full"
                                        id="env-light-intensity">
                                </div>
                                <button class="w-full btn-secondary px-4 py-2 rounded-lg text-sm font-medium"
                                    id="add-light-source-btn">
                                    <i class="fas fa-plus mr-2"></i>Add Light Source
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </aside>
        </div>

        <!-- Status Bar -->
        <footer class="status-bar h-8 px-6 flex items-center justify-between text-xs text-gray-400 code-font">
            <div class="flex items-center space-x-6">
                <span id="object-count">Objects: 0</span>
                <span id="triangle-count">Triangles: 0</span>
                <span id="vertex-count">Vertices: 0</span>
            </div>
            <div class="flex items-center space-x-6">
                <span id="zoom-level">Zoom: 100%</span>
                <span id="fps-counter">FPS: 60</span>
                <span class="flex items-center">
                    <div class="w-1.5 h-1.5 bg-primary-400 rounded-full mr-2"></div>
                    <span id="status-message">Ready</span>
                </span>
            </div>
        </footer>
    </div>

    <!-- Context Menu -->
    <div id="context-menu" class="context-menu fixed hidden min-w-[200px] py-2 z-50">
        <div class="context-item px-4 py-2 text-sm cursor-pointer" id="context-add-object">
            <i class="fas fa-plus w-4 mr-3"></i>Add Object
        </div>
        <div class="context-item px-4 py-2 text-sm cursor-pointer" id="context-paste">
            <i class="fas fa-paste w-4 mr-3"></i>Paste
        </div>
        <div class="h-px bg-gray-700 mx-2"></div>
        <div class="context-item px-4 py-2 text-sm cursor-pointer" id="context-select-all">
            <i class="fas fa-eye w-4 mr-3"></i>Select All
        </div>
        <!-- Add new context menu items -->
        <div class="context-item px-4 py-2 text-sm cursor-pointer" id="context-group">
            <i class="fas fa-object-group w-4 mr-3"></i>Group
        </div>
        <div class="context-item px-4 py-2 text-sm cursor-pointer" id="context-ungroup">
            <i class="fas fa-object-ungroup w-4 mr-3"></i>Ungroup
        </div>
        <div class="h-px bg-gray-700 mx-2"></div>
        <div class="context-item px-4 py-2 text-sm cursor-pointer" id="context-hide">
            <i class="fas fa-eye-slash w-4 mr-3"></i>Hide
        </div>
        <div class="context-item px-4 py-2 text-sm cursor-pointer" id="context-freeze">
            <i class="fas fa-snowflake w-4 mr-3"></i>Freeze
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification">
        <div class="flex items-center">
            <i class="fas fa-check-circle text-green-400 mr-2"></i>
            <span id="notification-message">Operation completed</span>
        </div>
    </div>

    <!-- File Input (hidden) -->
    <input type="file" id="file-input" accept=".json,.gltf,.glb" style="display: none;">
    <input type="file" id="image-input" accept="image/*" style="display: none;">

    <script>
        // ==============================================
        // CORE APPLICATION CLASSES
        // ==============================================

        class AppState {
            constructor() {
                this.resetState();
                this.layers = {
                    default: { id: 0, name: 'Default', visible: true, objects: [] }
                };
                this.viewportSettings = {
                    shading: 'solid',
                    gridVisible: true,
                    axesVisible: false,
                    statsVisible: true
                };
                this.materialLibrary = [
                    {
                        name: 'Default',
                        color: 0x808080,
                        roughness: 0.5,
                        metalness: 0
                    },
                    {
                        name: 'Metal',
                        color: 0xaaaaaa,
                        roughness: 0.2,
                        metalness: 1.0
                    },
                    {
                        name: 'Plastic',
                        color: 0xffffff,
                        roughness: 0.4,
                        metalness: 0
                    }
                ];
                // Add this:
                this.sculpting = {
                    currentMesh: null,
                    originalPositions: null,
                    vertexNormals: null,
                    activeVertices: [],
                    lastCenter: null,
                    vertexGroups: new Map()
                };
                this.snapSettings = {
                    enabled: false,
                    value: 0.25,
                    axisConstraints: { x: true, y: true, z: true }
                };
                this.groups = [];
                this.hiddenObjects = [];
                this.frozenObjects = [];
                this.textures = {
                    diffuse: {},
                    normal: {},
                    roughness: {}
                };
            }

            resetState() {
                this.sceneObjects = [];
                this.selectedObjects = [];
                this.lastObjectId = 0;
                this.activeTool = 'select';
                this.viewMode = 'solid';
                this.cameraMode = 'perspective';
                this.transformMode = 'location';
                this.clipboard = null;
                this.history = [];
                this.historyIndex = -1;
                this.maxHistoryStates = 100;
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.selectionBox = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } };
                this.performance = {
                    fps: 60,
                    frameTime: 16,
                    lastFrameTime: performance.now(),
                    frameCount: 0
                };
                this.brushSettings = {
                    size: 0.5,
                    strength: 0.5,
                    falloff: 0.5,
                    symmetry: 'none'
                };
            }

            generateId() {
                return ++this.lastObjectId;
            }

            addObject(object) {
                if (!object.id) object.id = this.generateId();
                this.sceneObjects.push(object);
                this.saveHistory();
                return object;
            }

            removeObject(objectId) {
                const index = this.sceneObjects.findIndex(obj => obj.id === objectId);
                if (index > -1) {
                    this.sceneObjects.splice(index, 1);
                    this.deselectObject(objectId);
                    this.saveHistory();
                    return true;
                }
                return false;
            }

            getObject(objectId) {
                return this.sceneObjects.find(obj => obj.id === objectId);
            }

            selectObject(objectId, multiSelect = false) {
                if (!multiSelect) {
                    this.selectedObjects = [];
                }

                if (!this.selectedObjects.includes(objectId)) {
                    this.selectedObjects.push(objectId);
                }
            }

            deselectObject(objectId) {
                this.selectedObjects = this.selectedObjects.filter(id => id !== objectId);
            }

            clearSelection() {
                this.selectedObjects = [];
            }

            getSelectedObjects() {
                return this.sceneObjects.filter(obj => this.selectedObjects.includes(obj.id));
            }

            // Save current state to history
            saveHistory() {
                // Skip saving if we're in the middle of a sculpt operation
                if (this.activeTool === 'sculpt' && this.isDragging) {
                    return;
                }

                const currentState = this.serializeState();
                const serializedState = JSON.stringify(currentState);

                // Don't save if identical to last state
                if (this.history[this.historyIndex] === serializedState) {
                    return;
                }

                // If we're not at the end of history, discard future states
                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }

                // Limit history size
                if (this.history.length >= this.maxHistoryStates) {
                    this.history.shift();
                } else {
                    this.historyIndex++;
                }

                this.history.push(serializedState);
            }

            undo() {
                if (this.historyIndex <= 0) return false;

                this.historyIndex--;
                this.restoreState(JSON.parse(this.history[this.historyIndex]));
                return true;
            }

            // Redo to next state
            redo() {
                if (this.historyIndex >= this.history.length - 1) return false;

                this.historyIndex++;
                this.restoreState(JSON.parse(this.history[this.historyIndex]));
                return true;
            }
            // Restore a state from serialized data
            restoreState(state) {
                // Clear current scene
                this.sceneObjects = [];
                this.sceneManager.scene.children.forEach(child => {
                    if (child !== this.sceneManager.camera &&
                        child !== this.sceneManager.controls &&
                        child !== this.sceneManager.gridHelper &&
                        child !== this.sceneManager.axesHelper) {
                        this.sceneManager.scene.remove(child);
                    }
                });

                // Restore objects
                state.sceneObjects.forEach(objData => {
                    const obj = {
                        id: objData.id,
                        type: objData.type,
                        name: objData.name,
                        userData: objData.userData
                    };

                    this.sceneObjects.push(obj);
                    const threeObj = this.sceneManager.addObject(obj);

                    if (threeObj && threeObj.threeObj) {
                        threeObj.threeObj.position.copy(objData.position);
                        threeObj.threeObj.rotation.copy(objData.rotation);
                        threeObj.threeObj.scale.copy(objData.scale);
                        threeObj.threeObj.visible = objData.visible;

                        if (threeObj.threeObj.material) {
                            threeObj.threeObj.material.color.setHex(objData.color);
                            threeObj.threeObj.material.roughness = objData.roughness;
                            threeObj.threeObj.material.metalness = objData.metalness;
                            threeObj.threeObj.material.needsUpdate = true;
                        }
                    }
                });

                // Restore selection
                this.selectedObjects = [...state.selectedObjects];

                // Restore camera
                if (state.camera && this.sceneManager.camera) {
                    this.sceneManager.camera.position.copy(state.camera.position);
                    this.sceneManager.camera.rotation.copy(state.camera.rotation);
                    if (this.sceneManager.camera.zoom !== undefined) {
                        this.sceneManager.camera.zoom = state.camera.zoom;
                        this.sceneManager.camera.updateProjectionMatrix();
                    }
                }

                // Restore view mode and active tool
                this.viewMode = state.viewMode || 'solid';
                this.activeTool = state.activeTool || 'select';

                // Update UI
                if (window.uiManager) {
                    window.uiManager.updateUI();
                    window.uiManager.updateViewModeButtons();
                    window.uiManager.updateToolButtons();
                }

                // Update scene manager
                this.sceneManager.setViewMode(this.viewMode);

                // Update selection in scene manager
                if (this.selectedObjects.length > 0) {
                    this.sceneManager.selectObject(this.selectedObjects[0]);
                } else {
                    this.sceneManager.clearSelection();
                }
            }

            toggleSnap(enabled) {
                this.snapSettings.enabled = enabled;
            }
            // In AppState class
            getSelectedThreeObjects(sceneManager) {
                return this.selectedObjects.map(id => sceneManager.getObject(id)).filter(obj => obj !== null);
            }
            setSnapValue(value) {
                this.snapSettings.value = parseFloat(value) || 0.25;
            }
            // Serialize the current state
            serializeState() {
                return {
                    sceneObjects: this.sceneObjects.map(obj => this.serializeObject(obj)),
                    selectedObjects: [...this.selectedObjects],
                    camera: {
                        position: this.sceneManager?.camera?.position?.clone() || new THREE.Vector3(5, 5, 5),
                        rotation: this.sceneManager?.camera?.rotation?.clone() || new THREE.Euler(),
                        zoom: this.sceneManager?.camera?.zoom || 1
                    },
                    viewMode: this.viewMode,
                    activeTool: this.activeTool
                };
            }

            // Serialize a single object
            serializeObject(obj) {
                const threeObj = this.sceneManager?.getObject(obj.id);
                return {
                    id: obj.id,
                    type: obj.type,
                    name: obj.name || `${obj.type}_${obj.id}`,
                    position: threeObj?.position?.clone() || new THREE.Vector3(0, 0, 0),
                    rotation: threeObj?.rotation?.clone() || new THREE.Euler(0, 0, 0),
                    scale: threeObj?.scale?.clone() || new THREE.Vector3(1, 1, 1),
                    color: threeObj?.material?.color?.getHex() || 0x808080,
                    roughness: threeObj?.material?.roughness || 0.5,
                    metalness: threeObj?.material?.metalness || 0,
                    visible: threeObj?.visible ?? true,
                    userData: { ...obj.userData }
                };
            }


            getMeshState(mesh) {
                if (!mesh || !mesh.geometry) return null;

                return {
                    positions: mesh.geometry.attributes.position.array.slice(),
                    normals: mesh.geometry.attributes.normal?.array.slice(),
                    indices: mesh.geometry.index?.array.slice()
                };
            }

            toggleAxisConstraint(axis) {
                if (this.snapSettings.axisConstraints.hasOwnProperty(axis)) {
                    this.snapSettings.axisConstraints[axis] = !this.snapSettings.axisConstraints[axis];
                }
            }
            copySelectedObjects() {
                const selectedObjects = this.getSelectedObjects();
                if (selectedObjects.length === 0) return null;

                // Create deep copies of the selected objects
                const copies = selectedObjects.map(obj => {
                    return {
                        ...obj,
                        id: this.generateId(),
                        name: `${obj.name}_copy` || `${obj.type}_${this.lastObjectId}`,
                        position: obj.position ? { ...obj.position } : null,
                        rotation: obj.rotation ? { ...obj.rotation } : null,
                        scale: obj.scale ? { ...obj.scale } : null
                    };
                });

                return copies;
            }
            groupObjects(objectIds) {
                if (objectIds.length < 2) return;
                const groupId = this.generateId();
                this.groups.push({
                    id: groupId,
                    name: `Group_${groupId}`,
                    objects: objectIds
                });
                this.saveHistory();
            }

            ungroupObjects(groupId) {
                const index = this.groups.findIndex(g => g.id === groupId);
                if (index > -1) {
                    this.groups.splice(index, 1);
                    this.saveHistory();
                }
            }

            toggleObjectVisibility(objectId) {
                const index = this.hiddenObjects.indexOf(objectId);
                if (index > -1) {
                    this.hiddenObjects.splice(index, 1);
                } else {
                    this.hiddenObjects.push(objectId);
                }
                this.saveHistory();
            }

            toggleObjectFreeze(objectId) {
                const index = this.frozenObjects.indexOf(objectId);
                if (index > -1) {
                    this.frozenObjects.splice(index, 1);
                } else {
                    this.frozenObjects.push(objectId);
                }
                this.saveHistory();
            }

            updatePerformance(deltaTime) {
                this.performance.frameCount++;
                if (performance.now() >= this.performance.lastFrameTime + 1000) {
                    this.performance.fps = Math.min(60, Math.round(this.performance.frameCount /
                        (performance.now() - this.performance.lastFrameTime) * 1000));
                    this.performance.frameCount = 0;
                    this.performance.lastFrameTime = performance.now();
                }
                this.performance.frameTime = deltaTime * 1000;
            }
        }

        class SceneManager {
            constructor(canvas) {
                if (!canvas) throw new Error('Canvas element is required');
                this.canvas = canvas;
                this.stats = {
                    triangles: 0,
                    vertices: 0,
                    drawCalls: 0
                };
                this.initThreeJS();
                this.setupLighting();
                this.setupHelpers();
                this.setupRaycasting();
                this.setupTransformControls();
                this.setupSculpting(); // Add this line
                this.setupBrushPreview(); // Add this line
            }

            initThreeJS() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1a1a1a);

                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
                this.configureRenderer();

                this.camera = new THREE.PerspectiveCamera(
                    75,
                    this.canvas.clientWidth / this.canvas.clientHeight,
                    0.1,
                    1000
                );
                this.resetCamera();

                this.controls = new THREE.OrbitControls(this.camera, this.canvas);
                this.configureOrbitControls();
            }

            setupRaycasting() {
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
            }

            setupTransformControls() {
                this.transformControls = new THREE.TransformControls(this.camera, this.renderer.domElement);

                // Improved event handling
                this.transformControls.addEventListener('dragging-changed', (event) => {
                    this.controls.enabled = !event.value;
                    if (!event.value) {
                        // When dragging ends, ensure the active tool is still selected
                        window.uiManager?.updateToolButtons();
                    }
                });

                this.transformControls.addEventListener('mouseDown', () => {
                    const uiManager = window.uiManager;
                    if (uiManager) {
                        uiManager.appState.activeTool = this.transformControls.getMode();
                        uiManager.updateToolButtons();
                    }
                });

                this.scene.add(this.transformControls);
                this.transformControls.visible = false;
                this.transformControls.enabled = false; // Start disabled
            }

            resetCamera(position = { x: 5, y: 5, z: 5 }) {
                this.camera.position.set(position.x, position.y, position.z);
                this.camera.lookAt(0, 0, 0);
                this.camera.up.set(0, 1, 0);
            }

            configureRenderer() {
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
            }

            configureOrbitControls() {
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.25;
                this.controls.screenSpacePanning = false;
                this.controls.maxPolarAngle = Math.PI;
                this.controls.minDistance = 1;
                this.controls.maxDistance = 50;
            }

            setupLighting() {
                this.ambientLight = new THREE.AmbientLight(0x404040, 1);
                this.scene.add(this.ambientLight);

                this.directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                this.directionalLight.position.set(5, 10, 7);
                this.directionalLight.castShadow = true;
                this.directionalLight.shadow.mapSize.width = 2048;
                this.directionalLight.shadow.mapSize.height = 2048;
                this.directionalLight.shadow.camera.near = 0.5;
                this.directionalLight.shadow.camera.far = 50;
                this.directionalLight.shadow.bias = -0.001;
                this.scene.add(this.directionalLight);

                this.hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.5);
                this.scene.add(this.hemisphereLight);
            }
            duplicateObject(objectData) {
                // Create a new object with the same properties but new ID
                const newObject = this.addObject(objectData);
                if (newObject) {
                    // Offset the position slightly so duplicates don't overlap
                    newObject.threeObj.position.x += 0.5;
                    newObject.threeObj.position.z += 0.5;
                }
                return newObject;
            }
            getMeshUnderPointer(mouse) {
                this.raycaster.setFromCamera(mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);

                for (let i = 0; i < intersects.length; i++) {
                    if (intersects[i].object.isMesh) {
                        return intersects[i];
                    }
                }
                return null;
            }

            getMeshVerticesInRadius(mesh, point, radius) {
                const vertices = [];
                const geometry = mesh.geometry;
                const positionAttribute = geometry.getAttribute('position');
                const matrixWorld = mesh.matrixWorld;
                const inverseMatrix = new THREE.Matrix4().getInverse(matrixWorld);

                // Transform point to mesh local space
                const localPoint = point.clone().applyMatrix4(inverseMatrix);

                for (let i = 0; i < positionAttribute.count; i++) {
                    const vertex = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);
                    const distance = vertex.distanceTo(localPoint);

                    if (distance <= radius) {
                        vertices.push({
                            index: i,
                            distance: distance,
                            originalPosition: vertex.clone(),
                            normal: this.getVertexNormal(mesh, i)
                        });
                    }
                }

                return vertices;
            }
            // Add to SceneManager class
            setupBrushPreview() {
                this.brushPreview = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 16, 16),
                    new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.3,
                        wireframe: true
                    })
                );
                this.brushPreview.visible = false;
                this.scene.add(this.brushPreview);
            }

            updateBrushPreview(position, size) {
                if (!this.brushPreview) return;
                this.brushPreview.position.copy(position);
                this.brushPreview.scale.set(size, size, size);
                this.brushPreview.visible = true;
            }

            hideBrushPreview() {
                if (this.brushPreview) {
                    this.brushPreview.visible = false;
                }
            }
            prepareMeshForSculpting(mesh) {
                if (!mesh.geometry.attributes.position) return;

                // Ensure we're working with non-indexed geometry
                if (mesh.geometry.index) {
                    mesh.geometry = mesh.geometry.toNonIndexed();
                }

                // Make sure we can modify the geometry
                mesh.geometry.attributes.position.needsUpdate = true;
                mesh.geometry.attributes.normal.needsUpdate = true;

                // Store original positions
                const positions = mesh.geometry.attributes.position;
                this.sculpting.originalPositions = new Float32Array(positions.array.length);
                this.sculpting.originalPositions.set(positions.array);

                // Set dynamic flag
                mesh.geometry.dynamic = true;
            }
            calculateVertexNormals(mesh) {
                const geometry = mesh.geometry;
                geometry.computeVertexNormals();
                this.sculpting.vertexNormals = [];

                const normals = geometry.getAttribute('normal');
                for (let i = 0; i < normals.count; i++) {
                    this.sculpting.vertexNormals.push(
                        new THREE.Vector3().fromBufferAttribute(normals, i)
                    );
                }
            }

            updateMeshVertices(mesh, vertices, newPositions) {
                const positionAttribute = mesh.geometry.getAttribute('position');

                for (let i = 0; i < vertices.length; i++) {
                    const vertex = vertices[i];
                    const newPosition = newPositions[i];
                    positionAttribute.setXYZ(vertex.index, newPosition.x, newPosition.y, newPosition.z);
                }

                positionAttribute.needsUpdate = true;
                mesh.geometry.computeVertexNormals();
            }
            setupHelpers() {
                this.gridHelper = new THREE.GridHelper(20, 20, 0x555555, 0x333333);
                this.gridHelper.position.y = -0.01;
                this.scene.add(this.gridHelper);

                this.axesHelper = new THREE.AxesHelper(5);
                this.axesHelper.visible = false;
                this.scene.add(this.axesHelper);

                this.selectionBox = new THREE.BoxHelper();
                this.selectionBox.material.depthTest = false;
                this.selectionBox.material.transparent = true;
                this.selectionBox.visible = false;
                this.scene.add(this.selectionBox);
            }
            applyBrushEffect(mesh, vertices, center, normal, strength, mode) {
                const positionAttribute = mesh.geometry.getAttribute('position');
                const matrixWorld = mesh.matrixWorld;
                const inverseMatrix = new THREE.Matrix4().getInverse(matrixWorld);
                const localCenter = center.clone().applyMatrix4(inverseMatrix);
                const localNormal = normal.clone().transformDirection(inverseMatrix);

                for (const vertex of vertices) {
                    const i = vertex.index * 3;
                    const vPos = new THREE.Vector3(
                        positionAttribute.array[i],
                        positionAttribute.array[i + 1],
                        positionAttribute.array[i + 2]
                    );

                    const influence = this.calculateBrushInfluence(
                        vertex.distance,
                        this.appState.brushSettings.size,
                        this.appState.brushSettings.falloff
                    );

                    const newPos = this.calculateNewPosition(
                        vPos,
                        localCenter,
                        localNormal,
                        strength * influence,
                        mode
                    );

                    positionAttribute.array[i] = newPos.x;
                    positionAttribute.array[i + 1] = newPos.y;
                    positionAttribute.array[i + 2] = newPos.z;
                }

                positionAttribute.needsUpdate = true;
                mesh.geometry.computeVertexNormals();
                mesh.geometry.computeBoundingBox();
                mesh.geometry.computeBoundingSphere();
            }

            calculateBrushInfluence(distance, size, falloff) {
                if (distance >= size) return 0;
                const t = distance / size;

                if (falloff < 0.33) return 1 - t; // Linear
                if (falloff < 0.66) return 1 - t * t; // Smooth
                return 1 - Math.pow(t, 4); // Sharp
            }
            resize() {
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;

                if (this.canvas.width !== width || this.canvas.height !== height) {
                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(width, height, false);
                }
            }
            calculateNewPosition(position, center, normal, strength, mode) {
                const newPos = position.clone();
                const direction = new THREE.Vector3().subVectors(center, position).normalize();

                switch (mode) {
                    case 'draw':
                        newPos.add(normal.multiplyScalar(strength));
                        break;
                    case 'smooth':
                        newPos.lerp(center, strength * 0.1);
                        break;
                    case 'flatten':
                        const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(normal, center);
                        const projected = plane.projectPoint(position, new THREE.Vector3());
                        newPos.lerp(projected, strength);
                        break;
                    case 'inflate':
                        newPos.add(direction.multiplyScalar(-strength));
                        break;
                    case 'pinch':
                        newPos.add(direction.multiplyScalar(strength));
                        break;
                    case 'grab':
                        if (this.sculpting.lastCenter) {
                            const moveVec = new THREE.Vector3().subVectors(center, this.sculpting.lastCenter);
                            newPos.add(moveVec.multiplyScalar(strength));
                        }
                        break;
                    case 'crevice':
                        newPos.add(normal.multiplyScalar(-strength));
                        break;
                }

                return newPos;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            addObject(objectData) {
                let object3D;
                let helper = null;

                switch (objectData.type) {
                    case 'box':
                        object3D = this.createBox(objectData);
                        break;
                    case 'sphere':
                        object3D = this.createSphere(objectData);
                        break;
                    case 'cylinder':
                        object3D = this.createCylinder(objectData);
                        break;
                    case 'cone':
                        object3D = this.createCone(objectData);
                        break;
                    case 'torus':
                        object3D = this.createTorus(objectData);
                        break;
                    case 'plane':
                        object3D = this.createPlane(objectData);
                        break;
                    case 'extrude':
                        object3D = this.createExtrudedShape(objectData);
                        break;
                    case 'light':
                        object3D = this.createLight(objectData);
                        helper = new THREE.PointLightHelper(object3D, 0.5);
                        this.scene.add(helper);
                        break;
                    case 'camera':
                        object3D = this.createCamera(objectData);
                        helper = new THREE.CameraHelper(object3D);
                        this.scene.add(helper);
                        break;
                    default:
                        console.warn(`Unknown object type: ${objectData.type}`);
                        return null;
                }

                if (objectData.position) {
                    object3D.position.set(
                        objectData.position.x || 0,
                        objectData.position.y || 0,
                        objectData.position.z || 0
                    );
                }

                if (objectData.rotation) {
                    object3D.rotation.set(
                        objectData.rotation.x || 0,
                        objectData.rotation.y || 0,
                        objectData.rotation.z || 0
                    );
                }

                if (objectData.scale) {
                    object3D.scale.set(
                        objectData.scale.x || 1,
                        objectData.scale.y || 1,
                        objectData.scale.z || 1
                    );
                }

                object3D.userData = {
                    id: objectData.id,
                    type: objectData.type,
                    name: objectData.name || `${objectData.type}_${objectData.id}`,
                    helper: helper
                };

                this.scene.add(object3D);
                this.updateStats();

                return { threeObj: object3D, helper };
            }

            createBox(data) {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(data.color || 0x808080),
                    roughness: data.roughness || 0.5,
                    metalness: data.metalness || 0
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }
            createExtrudedShape(data) {
                // Create a simple star shape for extrusion
                const starShape = new THREE.Shape();
                const x = 0, y = 0;
                const spikes = 5;
                const outerRadius = 0.5;
                const innerRadius = 0.2;

                starShape.moveTo(x, y + outerRadius);
                for (let i = 0; i < spikes * 2; i++) {
                    const angle = (i * Math.PI) / spikes;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    starShape.lineTo(
                        x + Math.sin(angle) * radius,
                        y + Math.cos(angle) * radius
                    );
                }
                starShape.lineTo(x, y + outerRadius);

                // Extrude settings
                const extrudeSettings = {
                    steps: 1,
                    depth: 1,
                    bevelEnabled: true,
                    bevelThickness: 0.1,
                    bevelSize: 0.1,
                    bevelOffset: 0,
                    bevelSegments: 3
                };

                const geometry = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(data.color || 0x808080),
                    roughness: data.roughness || 0.5,
                    metalness: data.metalness || 0,
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }
            performBooleanOperation(operation, objectA, objectB) {
                // Convert meshes to CSG
                const meshA = objectA.clone();
                const meshB = objectB.clone();

                // Ensure they're at the same position for the operation
                meshB.position.copy(objectB.position).sub(objectA.position);
                meshA.position.set(0, 0, 0);

                const csgA = ThreeBSP(meshA);
                const csgB = ThreeBSP(meshB);

                let resultCSG;

                switch (operation) {
                    case 'union':
                        resultCSG = csgA.union(csgB);
                        break;
                    case 'difference':
                        resultCSG = csgA.subtract(csgB);
                        break;
                    case 'intersect':
                        resultCSG = csgA.intersect(csgB);
                        break;
                    default:
                        console.error('Unknown boolean operation:', operation);
                        return null;
                }

                // Convert back to Three.js mesh
                const resultMesh = resultCSG.toMesh();

                // Copy material from first object
                resultMesh.material = objectA.material.clone();

                // Set position to first object's position
                resultMesh.position.copy(objectA.position);

                return resultMesh;
            }

            performBooleanOnSelected(operation) {
                const selected = this.transformControls.object;
                if (!selected) return false;

                // Find the other selected object (assuming exactly two are selected)
                let otherObject = null;
                this.scene.traverse(child => {
                    if (child !== selected && child.userData && child.userData.selected) {
                        otherObject = child;
                    }
                });

                if (!otherObject) {
                    console.warn('Need exactly two selected objects for boolean operation');
                    return false;
                }

                // Perform the boolean operation
                const resultMesh = this.performBooleanOperation(operation, selected, otherObject);

                if (resultMesh) {
                    // Remove original objects
                    this.scene.remove(selected);
                    this.scene.remove(otherObject);

                    // Add the result
                    resultMesh.userData = {
                        id: selected.userData.id,
                        type: 'boolean-result',
                        name: `${operation}_result`
                    };

                    this.scene.add(resultMesh);
                    this.transformControls.attach(resultMesh);

                    return true;
                }

                return false;
            }
            createSphere(data) {
                const geometry = new THREE.SphereGeometry(0.5, 32, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(data.color || 0x808080),
                    roughness: data.roughness || 0.5,
                    metalness: data.metalness || 0
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }

            createCylinder(data) {
                const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(data.color || 0x808080),
                    roughness: data.roughness || 0.5,
                    metalness: data.metalness || 0
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }

            createCone(data) {
                const geometry = new THREE.ConeGeometry(0.5, 1, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(data.color || 0x808080),
                    roughness: data.roughness || 0.5,
                    metalness: data.metalness || 0
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }

            createTorus(data) {
                const geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(data.color || 0x808080),
                    roughness: data.roughness || 0.5,
                    metalness: data.metalness || 0
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }

            createPlane(data) {
                const geometry = new THREE.PlaneGeometry(5, 5);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(data.color || 0x808080),
                    roughness: data.roughness || 0.5,
                    metalness: data.metalness || 0,
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.receiveShadow = true;
                return mesh;
            }

            createLight(data) {
                const light = new THREE.PointLight(0xffffff, data.intensity || 1, data.distance || 10);
                light.castShadow = true;
                light.shadow.mapSize.width = 1024;
                light.shadow.mapSize.height = 1024;
                light.shadow.camera.near = 0.1;
                light.shadow.camera.far = data.distance || 10;
                return light;
            }

            createCamera(data) {
                const camera = new THREE.PerspectiveCamera(
                    75,
                    this.canvas.clientWidth / this.canvas.clientHeight,
                    0.1,
                    1000
                );
                return camera;
            }

            removeObject(objectId) {
                let removed = false;
                this.scene.traverse(child => {
                    if (child.userData.id === objectId) {
                        this.scene.remove(child);
                        if (child.userData.helper) {
                            this.scene.remove(child.userData.helper);
                        }
                        removed = true;
                    }
                });
                if (removed) this.updateStats();
                return removed;
            }

            getObject(objectId) {
                let result = null;
                this.scene.traverse(child => {
                    if (child.userData.id === objectId) {
                        result = child;
                    }
                });
                return result;
            }

            selectObject(objectId) {
                const object = this.getObject(objectId);
                if (object) {
                    this.selectionBox.setFromObject(object);
                    this.selectionBox.visible = true;
                    this.transformControls.attach(object);
                    this.transformControls.visible = true;
                    return true;
                }
                this.clearSelection();
                return false;
            }

            clearSelection() {
                this.selectionBox.visible = false;
                this.transformControls.detach();
                this.transformControls.visible = false;
            }

            setTransformMode(mode) {
                if (['translate', 'rotate', 'scale'].includes(mode)) {
                    this.transformControls.setMode(mode);
                    this.transformControls.visible = this.transformControls.object !== null;
                }
            }
            setupSculpting() {
                this.sculpting = {
                    active: false,
                    currentMesh: null,
                    originalPositions: null,
                    vertexNormals: null,
                    activeVertices: [],
                    lastCenter: null,
                    vertexGroups: new Map()
                };
            }

            setViewMode(mode) {
                this.scene.traverse(child => {
                    if (child.isMesh) {
                        switch (mode) {
                            case 'wireframe':
                                child.material.wireframe = true;
                                child.material.transparent = false;
                                child.material.opacity = 1;
                                break;
                            case 'solid':
                                child.material.wireframe = false;
                                child.material.transparent = false;
                                child.material.opacity = 1;
                                break;
                            case 'material':
                                child.material.wireframe = false;
                                child.material.transparent = false;
                                child.material.opacity = 1;
                                child.material.envMap = null;
                                child.material.lightMap = null;
                                child.material.emissiveMap = null;
                                break;
                            case 'rendered':
                                child.material.wireframe = false;
                                break;
                        }
                        child.material.needsUpdate = true;
                    }
                });
            }
            updateTransformControls() {
                if (this.transformControls.object) {
                    this.transformControls.update();
                }
            }

            setCameraView(view) {
                switch (view) {
                    case 'front':
                        this.camera.position.set(0, 0, 10);
                        this.camera.lookAt(0, 0, 0);
                        this.camera.up.set(0, 1, 0);
                        break;
                    case 'side':
                        this.camera.position.set(10, 0, 0);
                        this.camera.lookAt(0, 0, 0);
                        this.camera.up.set(0, 1, 0);
                        break;
                    case 'top':
                        this.camera.position.set(0, 10, 0);
                        this.camera.lookAt(0, 0, 0);
                        this.camera.up.set(0, 0, -1);
                        break;
                    case 'perspective':
                        this.camera.position.set(5, 5, 5);
                        this.camera.lookAt(0, 0, 0);
                        this.camera.up.set(0, 1, 0);
                        break;
                }
                this.controls.update();
            }

            updateStats() {
                this.stats.triangles = 0;
                this.stats.vertices = 0;
                this.stats.drawCalls = 0;

                this.scene.traverse(child => {
                    if (child.isMesh && child.geometry) {
                        if (child.geometry.index) {
                            this.stats.triangles += child.geometry.index.count / 3;
                        } else {
                            this.stats.triangles += child.geometry.attributes.position.count / 3;
                        }
                        this.stats.vertices += child.geometry.attributes.position.count;
                    }
                });
            }

            applyTexture(mesh, textureType, textureUrl) {
                if (!mesh || !mesh.material) return;

                const loader = new THREE.TextureLoader();
                loader.load(textureUrl, (texture) => {
                    texture.encoding = THREE.sRGBEncoding;

                    switch (textureType) {
                        case 'diffuse':
                            mesh.material.map = texture;
                            break;
                        case 'normal':
                            mesh.material.normalMap = texture;
                            break;
                        case 'roughness':
                            mesh.material.roughnessMap = texture;
                            break;
                    }
                    mesh.material.needsUpdate = true;
                });
            }
        }

        class UIManager {
            constructor(appState, sceneManager) {
                this.appState = appState;
                this.sceneManager = sceneManager;
                this.appState.activeTool = 'select';
                this.currentTextureType = 'diffuse';
                this.cacheElements();
                this.initTabSystem();
                this.initMaterialEditor();
                this.initEventListeners();
                this.initPanelToggles();
                this.initContextMenu();
                this.updateUI();
            }

            cacheElements() {
                this.elements = {
                    canvas: document.getElementById('three-canvas'),
                    viewport: document.getElementById('viewport'),
                    welcomeScreen: document.getElementById('welcome-screen'),
                    sceneHierarchy: document.getElementById('scene-hierarchy'),
                    emptySceneMessage: document.getElementById('empty-scene-message'),
                    propertiesPanel: document.getElementById('properties-panel'),
                    noSelectionMessage: document.getElementById('no-selection-message'),
                    transformValues: document.getElementById('transform-values'),
                    materialPanel: document.getElementById('material-panel'),
                    objectCount: document.getElementById('object-count'),
                    triangleCount: document.getElementById('triangle-count'),
                    vertexCount: document.getElementById('vertex-count'),
                    fpsCounter: document.getElementById('fps-counter'),
                    statusMessage: document.getElementById('status-message'),
                    zoomLevel: document.getElementById('zoom-level'),
                    progressBar: document.getElementById('progress-bar'),
                    notification: document.getElementById('notification'),
                    notificationMessage: document.getElementById('notification-message'),
                    colorPicker: document.getElementById('color-picker-input'),
                    colorInput: document.createElement('input'),
                    metallicSlider: document.getElementById('metallic-slider'),
                    metallicValue: document.getElementById('metallic-value'),
                    roughnessSlider: document.getElementById('roughness-slider'),
                    roughnessValue: document.getElementById('roughness-value'),
                    snapToggle: document.getElementById('snap-toggle'),
                    xAxisBtn: document.querySelector('[data-axis="x"]'),
                    yAxisBtn: document.querySelector('[data-axis="y"]'),
                    zAxisBtn: document.querySelector('[data-axis="z"]'),
                    diffuseMapBtn: document.getElementById('diffuse-map-btn'),
                    normalMapBtn: document.getElementById('normal-map-btn'),
                    roughnessMapBtn: document.getElementById('roughness-map-btn'),
                    clearDiffuseBtn: document.getElementById('clear-diffuse-btn'),
                    clearNormalBtn: document.getElementById('clear-normal-btn'),
                    clearRoughnessBtn: document.getElementById('clear-roughness-btn'),
                    imageInput: document.getElementById('image-input')
                };

                this.elements.colorInput.type = 'hidden';
                this.elements.colorInput.id = 'hidden-color-input';
                document.body.appendChild(this.elements.colorInput);
            }

            initTabSystem() {
                const tabs = document.querySelectorAll('[data-tab]');
                const panels = document.querySelectorAll('.sculpting-panel');

                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        tabs.forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');

                        const panelId = `${tab.dataset.tab}-panel`;
                        panels.forEach(panel => {
                            panel.style.display = panel.id === panelId ? 'block' : 'none';
                        });
                    });
                });

                if (tabs.length > 0) tabs[0].click();
            }

            initMaterialEditor() {
                $(this.elements.colorPicker).spectrum({
                    color: "#808080",
                    preferredFormat: "hex",
                    showInput: true,
                    showAlpha: false,
                    allowEmpty: false,
                    change: (color) => {
                        this.elements.colorInput.value = color.toHexString();
                        this.updateSelectedMaterial();
                    }
                });

                this.elements.metallicSlider.addEventListener('input', (e) => {
                    this.elements.metallicValue.textContent = parseFloat(e.target.value).toFixed(2);
                    this.updateSelectedMaterial();
                });

                this.elements.roughnessSlider.addEventListener('input', (e) => {
                    this.elements.roughnessValue.textContent = parseFloat(e.target.value).toFixed(2);
                    this.updateSelectedMaterial();
                });
            }

            initEventListeners() {
                // Tool buttons
                document.getElementById('select-tool-btn').addEventListener('click', () => {
                    this.appState.activeTool = 'select';
                    this.sceneManager.transformControls.setMode('translate');
                    this.sceneManager.transformControls.enabled = false; // Disable transform controls in select mode
                    this.updateToolButtons();
                });

                document.getElementById('translate-tool-btn').addEventListener('click', () => {
                    this.appState.activeTool = 'translate';
                    this.sceneManager.transformControls.setMode('translate');
                    this.sceneManager.transformControls.enabled = true;
                    this.updateToolButtons();
                });

                document.getElementById('rotate-tool-btn').addEventListener('click', () => {
                    this.appState.activeTool = 'rotate';
                    this.sceneManager.setTransformMode('rotate');
                    this.updateToolButtons();
                });

                document.getElementById('scale-tool-btn').addEventListener('click', () => {
                    this.appState.activeTool = 'scale';
                    this.sceneManager.setTransformMode('scale');
                    this.updateToolButtons();
                });

                // View mode buttons
                document.querySelectorAll('[data-view-mode]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.appState.viewMode = btn.dataset.viewMode;
                        this.sceneManager.setViewMode(this.appState.viewMode);
                        this.updateViewModeButtons();
                    });
                });
                // Duplicate button
                document.getElementById('duplicate-btn').addEventListener('click', () => {
                    this.duplicateSelectedObjects();
                });

                // Camera view buttons
                document.querySelectorAll('[data-camera-view]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.appState.cameraMode = btn.dataset.cameraView;
                        this.sceneManager.setCameraView(this.appState.cameraMode);
                        this.updateUI();
                    });
                });

                // Transform tabs
                document.querySelectorAll('[data-transform-tab]').forEach(tab => {
                    tab.addEventListener('click', () => {
                        this.appState.transformMode = tab.dataset.transformTab;
                        this.updateTransformTabs();
                        this.updateTransformInputs();
                    });
                });

                // Create shape buttons
                document.querySelectorAll('.create-shape').forEach(shape => {
                    shape.addEventListener('click', () => {
                        this.createObject(shape.dataset.shape);
                    });
                });

                // Sculpting tools
                this.elements.canvas.addEventListener('mousedown', (e) => {
                    if (this.appState.activeTool === 'sculpt') {
                        this.handleSculptStart(e);
                    } else {
                        this.handleCanvasMouseDown(e);
                    }
                });
                this.elements.canvas.addEventListener('mousemove', (e) => {
                    if (this.appState.activeTool === 'sculpt' && this.isSculpting) {
                        this.handleSculptMove(e);
                    } else {
                        this.handleCanvasMouseMove(e);
                    }
                });
                this.elements.canvas.addEventListener('mouseup', (e) => {
                    if (this.isSculpting) {
                        this.handleSculptEnd();
                    } else {
                        this.handleCanvasMouseUp(e);
                    }
                });


                document.getElementById('brush-size').addEventListener('input', (e) => {
                    this.appState.brushSettings.size = parseFloat(e.target.value);
                    document.getElementById('brush-size-value').textContent = e.target.value;
                });

                // Brush strength
                document.getElementById('brush-strength').addEventListener('input', (e) => {
                    this.appState.brushSettings.strength = parseFloat(e.target.value);
                    document.getElementById('brush-strength-value').textContent = e.target.value;
                });

                // Brush falloff
                document.getElementById('brush-falloff').addEventListener('input', (e) => {
                    this.appState.brushSettings.falloff = parseFloat(e.target.value);
                    document.getElementById('brush-falloff-value').textContent = e.target.value;
                });
                // Sculpt undo/redo
                document.getElementById('sculpt-undo-btn').addEventListener('click', () => {
                    if (this.appState.undo()) {
                        this.updateScene();
                        this.showNotification('Sculpt undo', 'success');
                    }
                });

                document.getElementById('sculpt-redo-btn').addEventListener('click', () => {
                    if (this.appState.redo()) {
                        this.updateScene();
                        this.showNotification('Sculpt redo', 'success');
                    }
                });
                // File operations
                document.getElementById('new-project-btn').addEventListener('click', () => {
                    this.newProject();
                });

                document.getElementById('open-project-btn').addEventListener('click', () => {
                    document.getElementById('file-input').click();
                });

                // Replace your existing export button code with this
                document.getElementById('export-scene-btn').addEventListener('click', () => {
                    const exporter = new THREE.GLTFExporter();
                    exporter.parse(sceneManager.scene, (gltf) => {
                        // Send the model data to React
                        window.parent.postMessage({
                            type: 'SAVE_MODEL',
                            modelData: gltf
                        }, window.location.origin);
                    });
                });
                // Edit operations
                document.getElementById('undo-btn').addEventListener('click', () => {
                    if (this.appState.undo()) {
                        this.updateScene();
                        this.showNotification('Undo successful', 'success');
                    } else {
                        this.showNotification('Nothing to undo', 'warning');
                    }
                });

                document.getElementById('redo-btn').addEventListener('click', () => {
                    if (this.appState.redo()) {
                        this.updateScene();
                        this.showNotification('Redo successful', 'success');
                    } else {
                        this.showNotification('Nothing to redo', 'warning');
                    }
                });

                document.getElementById('delete-btn').addEventListener('click', () => {
                    this.deleteSelectedObjects();
                });

                // Welcome screen buttons
                document.getElementById('add-cube-welcome-btn').addEventListener('click', () => {
                    this.createObject('box');
                });

                document.getElementById('open-project-welcome-btn').addEventListener('click', () => {
                    document.getElementById('file-input').click();
                });
                // Escape key to exit transform mode
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.appState.activeTool = 'select';
                        this.updateToolButtons();
                    }
                });
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ctrl+C or Cmd+C for copy
                    if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                        e.preventDefault();
                        this.duplicateSelectedObjects();
                    }

                    // Delete key for delete
                    if (e.key === 'Delete') {
                        e.preventDefault();
                        this.deleteSelectedObjects();
                    }
                });
                // Texture buttons
                this.elements.diffuseMapBtn.addEventListener('click', () => {
                    this.currentTextureType = 'diffuse';
                    this.elements.imageInput.click();
                });

                this.elements.normalMapBtn.addEventListener('click', () => {
                    this.currentTextureType = 'normal';
                    this.elements.imageInput.click();
                });

                this.elements.roughnessMapBtn.addEventListener('click', () => {
                    this.currentTextureType = 'roughness';
                    this.elements.imageInput.click();
                });

                this.elements.clearDiffuseBtn.addEventListener('click', () => {
                    this.clearTexture('diffuse');
                });

                this.elements.clearNormalBtn.addEventListener('click', () => {
                    this.clearTexture('normal');
                });

                this.elements.clearRoughnessBtn.addEventListener('click', () => {
                    this.clearTexture('roughness');
                });

                // Image input handler
                this.elements.imageInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.applyTextureToSelected(e.target.files[0]);
                    }
                });
                // Boolean operation buttons
                document.getElementById('boolean-union-btn').addEventListener('click', () => {
                    if (this.sceneManager.performBooleanOnSelected('union')) {
                        this.showNotification('Union operation applied', 'success');
                    } else {
                        this.showNotification('Select exactly two objects for boolean operation', 'warning');
                    }
                });

                document.getElementById('boolean-difference-btn').addEventListener('click', () => {
                    if (this.sceneManager.performBooleanOnSelected('difference')) {
                        this.showNotification('Difference operation applied', 'success');
                    } else {
                        this.showNotification('Select exactly two objects for boolean operation', 'warning');
                    }
                });

                document.getElementById('boolean-intersect-btn').addEventListener('click', () => {
                    if (this.sceneManager.performBooleanOnSelected('intersect')) {
                        this.showNotification('Intersection operation applied', 'success');
                    } else {
                        this.showNotification('Select exactly two objects for boolean operation', 'warning');
                    }
                });
                // Snap settings
                if (this.elements.snapToggle) {
                    this.elements.snapToggle.addEventListener('change', (e) => {
                        this.appState.snapSettings.enabled = e.target.checked;
                    });
                }

                // Axis constraints
                if (this.elements.xAxisBtn) {
                    this.elements.xAxisBtn.addEventListener('click', () => {
                        this.appState.toggleAxisConstraint('x');
                        this.updateAxisConstraintButtons();
                    });
                }

                if (this.elements.yAxisBtn) {
                    this.elements.yAxisBtn.addEventListener('click', () => {
                        this.appState.toggleAxisConstraint('y');
                        this.updateAxisConstraintButtons();
                    });
                }

                if (this.elements.zAxisBtn) {
                    this.elements.zAxisBtn.addEventListener('click', () => {
                        this.appState.toggleAxisConstraint('z');
                        this.updateAxisConstraintButtons();
                    });
                }

                // Canvas event listeners
                this.elements.canvas.addEventListener('mousedown', (e) => this.handleCanvasMouseDown(e));
                this.elements.canvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
                this.elements.canvas.addEventListener('mouseup', (e) => this.handleCanvasMouseUp(e));
                this.elements.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));

                // Transform input changes
                this.elements.transformValues.querySelectorAll('input').forEach(input => {
                    input.addEventListener('change', () => this.handleTransformInputChange());
                });

                // Window resize
                window.addEventListener('resize', () => {
                    this.sceneManager.resize();
                });
            }

            initPanelToggles() {
                // Left panel toggle
                document.getElementById('left-panel-toggle').addEventListener('click', () => {
                    const leftPanel = document.querySelector('aside:first-child');
                    const toggleBtn = document.getElementById('left-panel-toggle');

                    leftPanel.classList.toggle('collapsed');
                    if (leftPanel.classList.contains('collapsed')) {
                        toggleBtn.innerHTML = '<i class="fas fa-chevron-right"></i>';
                        toggleBtn.style.right = '-16px';
                    } else {
                        toggleBtn.innerHTML = '<i class="fas fa-chevron-left"></i>';
                    }
                    this.sceneManager.resize();
                });

                // Right panel toggle
                document.getElementById('right-panel-toggle').addEventListener('click', () => {
                    const rightPanel = document.querySelector('aside:last-child');
                    const toggleBtn = document.getElementById('right-panel-toggle');

                    rightPanel.classList.toggle('collapsed');
                    if (rightPanel.classList.contains('collapsed')) {
                        toggleBtn.innerHTML = '<i class="fas fa-chevron-left"></i>';
                        toggleBtn.style.left = '-16px';
                    } else {
                        toggleBtn.innerHTML = '<i class="fas fa-chevron-right"></i>';
                    }
                    this.sceneManager.resize();
                });
            }

            duplicateSelectedObjects() {
                const copies = this.appState.copySelectedObjects();
                if (!copies || copies.length === 0) {
                    this.showNotification('No objects selected to duplicate', 'warning');
                    return;
                }

                // Add the copies to the scene
                copies.forEach(copy => {
                    this.appState.addObject(copy);
                    this.sceneManager.duplicateObject(copy);
                });

                // Select the new copies
                this.appState.clearSelection();
                copies.forEach(copy => {
                    this.appState.selectObject(copy.id, true);
                });

                this.updateUI();
                this.showNotification(`${copies.length} object(s) duplicated`, 'success');
            }

            // Update in UIManager class
            initSculpting() {
                this.isSculpting = false;
                this.lastMousePosition = null;

                // Existing event listeners should be modified to check for sculpt mode
                this.elements.canvas.addEventListener('mousedown', (e) => {
                    if (this.appState.activeTool === 'sculpt') {
                        this.handleSculptStart(e);
                    }
                });

                this.elements.canvas.addEventListener('mousemove', (e) => {
                    if (this.appState.activeTool === 'sculpt' && this.isSculpting) {
                        this.handleSculptMove(e);
                    }
                });

                this.elements.canvas.addEventListener('mouseup', () => {
                    if (this.isSculpting) {
                        this.handleSculptEnd();
                    }
                });
            }

            handleSculptStart(e) {
                // Only proceed if we're actually in sculpt mode
                if (this.appState.activeTool !== 'sculpt') return;

                this.sceneManager.mouse.x = (e.clientX / this.elements.canvas.clientWidth) * 2 - 1;
                this.sceneManager.mouse.y = -(e.clientY / this.elements.canvas.clientHeight) * 2 + 1;

                const intersection = this.sceneManager.getMeshUnderPointer(this.sceneManager.mouse);

                // Only start sculpting if we actually hit a mesh
                if (intersection && intersection.object.isMesh) {
                    this.isSculpting = true;
                    this.lastMousePosition = { x: e.clientX, y: e.clientY };

                    // Prepare the mesh for sculpting
                    this.sceneManager.prepareMeshForSculpting(intersection.object);
                    this.sceneManager.sculpting.currentMesh = intersection.object;
                    this.sceneManager.sculpting.lastCenter = intersection.point;

                    // Get vertices in brush radius
                    const vertices = this.sceneManager.getMeshVerticesInRadius(
                        intersection.object,
                        intersection.point,
                        this.appState.brushSettings.size
                    );

                    // Store initial state
                    this.sceneManager.sculpting.activeVertices = vertices;
                } else {
                    // If we didn't hit a mesh, don't start sculpting
                    this.isSculpting = false;
                }
            }
            handleSculptMove(e) {
                if (!this.isSculpting || !this.sceneManager.sculpting.currentMesh) return;

                this.sceneManager.mouse.x = (e.clientX / this.elements.canvas.clientWidth) * 2 - 1;
                this.sceneManager.mouse.y = -(e.clientY / this.elements.canvas.clientHeight) * 2 + 1;

                const intersection = this.sceneManager.getMeshUnderPointer(this.sceneManager.mouse);
                if (intersection && intersection.object === this.sceneManager.sculpting.currentMesh) {
                    const currentMousePos = { x: e.clientX, y: e.clientY };
                    const delta = {
                        x: currentMousePos.x - this.lastMousePosition.x,
                        y: currentMousePos.y - this.lastMousePosition.y
                    };

                    // Apply brush effect
                    this.sceneManager.applyBrushEffect(
                        intersection.object,
                        this.sceneManager.sculpting.activeVertices,
                        intersection.point,
                        intersection.face.normal,
                        this.appState.brushSettings.strength * 0.1,
                        this.appState.sculptMode
                    );

                    this.lastMousePosition = currentMousePos;
                    this.sceneManager.sculpting.lastCenter = intersection.point;
                }
            }


            handleSculptEnd() {
                if (this.isSculpting) {
                    this.isSculpting = false;
                    this.appState.saveHistory();
                    this.sceneManager.sculpting.currentMesh = null;
                    this.sceneManager.sculpting.activeVertices = null;
                    this.sceneManager.sculpting.lastCenter = null;
                }
            }

            initContextMenu() {
                const contextMenu = document.getElementById('context-menu');

                document.getElementById('context-add-object').addEventListener('click', () => {
                    this.createObject('box');
                    contextMenu.classList.add('hidden');
                });

                document.getElementById('context-select-all').addEventListener('click', () => {
                    this.selectAllObjects();
                    contextMenu.classList.add('hidden');
                });

                document.getElementById('context-group').addEventListener('click', () => {
                    this.groupSelectedObjects();
                    contextMenu.classList.add('hidden');
                });

                document.getElementById('context-ungroup').addEventListener('click', () => {
                    this.ungroupSelectedObjects();
                    contextMenu.classList.add('hidden');
                });

                document.getElementById('context-hide').addEventListener('click', () => {
                    this.toggleSelectedObjectsVisibility();
                    contextMenu.classList.add('hidden');
                });

                document.getElementById('context-freeze').addEventListener('click', () => {
                    this.toggleSelectedObjectsFreeze();
                    contextMenu.classList.add('hidden');
                });

                // Show context menu on right-click
                this.elements.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    contextMenu.style.left = `${e.clientX}px`;
                    contextMenu.style.top = `${e.clientY}px`;
                    contextMenu.classList.remove('hidden');
                });

                // Hide context menu on click elsewhere
                document.addEventListener('click', () => {
                    contextMenu.classList.add('hidden');
                });
            }

            updateUI() {
                this.updateSceneHierarchy();
                this.updatePropertiesPanel();
                this.updateToolButtons();
                this.updateViewModeButtons();
                this.updateTransformTabs();
                this.updateTransformInputs();
                this.updateSculptTools();
                this.updateAxisConstraintButtons();
                this.updateStats();
                this.updateWelcomeScreen();
            }

            updateSceneHierarchy() {
                const sceneHierarchy = this.elements.sceneHierarchy;
                sceneHierarchy.innerHTML = '';

                this.appState.sceneObjects.forEach(obj => {
                    const item = document.createElement('li');
                    item.className = 'scene-item';
                    if (this.appState.selectedObjects.includes(obj.id)) {
                        item.classList.add('selected');
                    }

                    item.innerHTML = `
                <div class="flex items-center">
                    <i class="fas fa-${this.getObjectIcon(obj.type)} mr-2"></i>
                    <span class="text-sm">${obj.name || `${obj.type}_${obj.id}`}</span>
                </div>
            `;

                    item.addEventListener('click', (e) => {
                        const multiSelect = e.ctrlKey || e.metaKey;
                        this.selectObjectInScene(obj.id, multiSelect);
                    });

                    sceneHierarchy.appendChild(item);
                });

                this.elements.emptySceneMessage.style.display =
                    this.appState.sceneObjects.length === 0 ? 'block' : 'none';
            }

            updatePropertiesPanel() {
                const selectedObjects = this.appState.getSelectedObjects();
                const panel = this.elements.propertiesPanel;

                if (selectedObjects.length === 0) {
                    this.elements.noSelectionMessage.style.display = 'block';
                    panel.innerHTML = '';
                    return;
                }

                this.elements.noSelectionMessage.style.display = 'none';

                // For simplicity, we'll just show properties of the first selected object
                const obj = selectedObjects[0];
                panel.innerHTML = `
            <div class="space-y-4">
                <div>
                    <label class="block text-xs text-gray-400 mb-2">Name</label>
                    <input type="text" value="${obj.name || `${obj.type}_${obj.id}`}" 
                        class="property-input w-full px-3 py-2 rounded-lg text-sm">
                </div>
                <div>
                    <label class="block text-xs text-gray-400 mb-2">Type</label>
                    <div class="glass px-3 py-2 rounded-lg text-sm">${obj.type}</div>
                </div>
                ${obj.type === 'light' ? `
                <div>
                    <label class="block text-xs text-gray-400 mb-2">Intensity</label>
                    <input type="range" min="0" max="10" step="0.1" value="${obj.intensity || 1}" 
                        class="w-full" id="light-intensity">
                </div>
                ` : ''}
            </div>
        `;

                // Add event listeners for dynamic properties
                if (obj.type === 'light') {
                    panel.querySelector('#light-intensity').addEventListener('input', (e) => {
                        const threeObj = this.sceneManager.getObject(obj.id);
                        if (threeObj) {
                            threeObj.intensity = parseFloat(e.target.value);
                        }
                    });
                }
            }
            updateToolButtons() {
                const tools = ['select', 'translate', 'rotate', 'scale', 'sculpt'];
                tools.forEach(tool => {
                    const btn = document.getElementById(`${tool}-tool-btn`);
                    if (btn) {
                        if (tool === this.appState.activeTool) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    }
                });

                // Ensure select tool is active by default
                if (!this.appState.activeTool) {
                    this.appState.activeTool = 'select';
                    document.getElementById('select-tool-btn').classList.add('active');
                }

                // Properly manage transform controls
                if (this.appState.activeTool === 'select' || this.appState.activeTool === 'sculpt') {
                    this.sceneManager.transformControls.detach();
                    this.sceneManager.transformControls.enabled = false;
                } else {
                    this.sceneManager.transformControls.setMode(this.appState.activeTool);
                    this.sceneManager.transformControls.enabled = true;

                    // Re-attach to selected object if one exists
                    const selectedObjects = this.appState.getSelectedObjects();
                    if (selectedObjects.length > 0) {
                        const threeObj = this.sceneManager.getObject(selectedObjects[0].id);
                        if (threeObj) {
                            this.sceneManager.transformControls.attach(threeObj);
                        }
                    }
                }
            }

            updateViewModeButtons() {
                document.querySelectorAll('[data-view-mode]').forEach(btn => {
                    if (btn.dataset.viewMode === this.appState.viewMode) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
            }

            updateTransformTabs() {
                document.querySelectorAll('[data-transform-tab]').forEach(tab => {
                    if (tab.dataset.transformTab === this.appState.transformMode) {
                        tab.classList.add('active');
                    } else {
                        tab.classList.remove('active');
                    }
                });
            }

            updateTransformInputs() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) return;

                // For simplicity, we'll just use the first selected object
                const obj = this.sceneManager.getObject(selectedObjects[0].id);
                if (!obj) return;

                const inputs = this.elements.transformValues.querySelectorAll('input');

                if (this.appState.transformMode === 'location') {
                    inputs[0].value = obj.position.x.toFixed(3);
                    inputs[1].value = obj.position.y.toFixed(3);
                    inputs[2].value = obj.position.z.toFixed(3);
                } else if (this.appState.transformMode === 'rotation') {
                    inputs[0].value = THREE.MathUtils.radToDeg(obj.rotation.x).toFixed(3);
                    inputs[1].value = THREE.MathUtils.radToDeg(obj.rotation.y).toFixed(3);
                    inputs[2].value = THREE.MathUtils.radToDeg(obj.rotation.z).toFixed(3);
                } else if (this.appState.transformMode === 'scale') {
                    inputs[0].value = obj.scale.x.toFixed(3);
                    inputs[1].value = obj.scale.y.toFixed(3);
                    inputs[2].value = obj.scale.z.toFixed(3);
                }
            }

            updateSculptTools() {
                document.querySelectorAll('.sculpt-tool').forEach(tool => {
                    if (tool.dataset.tool === this.appState.sculptMode) {
                        tool.classList.add('active');
                    } else {
                        tool.classList.remove('active');
                    }
                });
            }

            updateAxisConstraintButtons() {
                const constraints = this.appState.snapSettings.axisConstraints;
                this.elements.xAxisBtn.classList.toggle('active', constraints.x);
                this.elements.yAxisBtn.classList.toggle('active', constraints.y);
                this.elements.zAxisBtn.classList.toggle('active', constraints.z);
            }

            updateStats() {
                this.elements.objectCount.textContent = `Objects: ${this.appState.sceneObjects.length}`;
                this.elements.triangleCount.textContent = `Triangles: ${this.sceneManager.stats.triangles}`;
                this.elements.vertexCount.textContent = `Vertices: ${this.sceneManager.stats.vertices}`;
                this.elements.fpsCounter.textContent = `FPS: ${this.appState.performance.fps}`;
            }

            updateWelcomeScreen() {
                this.elements.welcomeScreen.style.display =
                    this.appState.sceneObjects.length === 0 ? 'flex' : 'none';
            }

            updateSelectedMaterial() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) return;

                const color = new THREE.Color(this.elements.colorInput.value);
                const metallic = parseFloat(this.elements.metallicSlider.value);
                const roughness = parseFloat(this.elements.roughnessSlider.value);

                selectedObjects.forEach(obj => {
                    const threeObj = this.sceneManager.getObject(obj.id);
                    if (threeObj && threeObj.material) {
                        threeObj.material.color.copy(color);
                        threeObj.material.metalness = metallic;
                        threeObj.material.roughness = roughness;
                        threeObj.material.needsUpdate = true;
                    }
                });

                this.appState.saveHistory(); // Save state after material change
            }

            getObjectIcon(type) {
                const icons = {
                    box: 'cube',
                    sphere: 'globe',
                    cylinder: 'database',
                    cone: 'concierge-bell',
                    torus: 'ring',
                    plane: 'square',
                    light: 'lightbulb',
                    camera: 'camera'
                };
                return icons[type] || 'cube';
            }

            handleCanvasMouseDown(e) {
                if (e.button !== 0) return; // Only left mouse button
                // Check for sculpt mode first
                if (this.appState.activeTool === 'sculpt') {
                    this.handleSculptStart(e);
                    return;
                }
                this.appState.isDragging = true;
                this.appState.dragStart = {
                    x: e.clientX,
                    y: e.clientY
                };

                // For selection box
                if (this.appState.activeTool === 'select' && !e.ctrlKey && !e.metaKey) {
                    this.appState.selectionBox.start = {
                        x: e.clientX,
                        y: e.clientY
                    };
                    this.appState.selectionBox.end = {
                        x: e.clientX,
                        y: e.clientY
                    };
                }
            }

            handleCanvasMouseMove(e) {
                if (!this.appState.isDragging) return;

                // Update selection box
                if (this.appState.activeTool === 'select' && !e.ctrlKey && !e.metaKey) {
                    this.appState.selectionBox.end = {
                        x: e.clientX,
                        y: e.clientY
                    };
                    // Here you would update the visual selection box
                }
            }

            handleCanvasMouseUp(e) {
                if (!this.appState.isDragging) return;
                this.appState.isDragging = false;

                // Handle selection box
                if (this.appState.activeTool === 'select' && !e.ctrlKey && !e.metaKey) {
                    // Here you would process the selection box area
                    // For now, we'll just clear it
                    this.appState.selectionBox.start = { x: 0, y: 0 };
                    this.appState.selectionBox.end = { x: 0, y: 0 };
                }
            }

            handleCanvasClick(e) {
                if (e.button !== 0) return; // Only left mouse button

                // Don't process clicks if we're in the middle of a transform
                if (this.appState.activeTool === 'sculpt' ||
                    this.sceneManager.transformControls.dragging) {
                    return;
                }

                // Convert mouse position to normalized device coordinates
                this.sceneManager.mouse.x = (e.clientX / this.elements.canvas.clientWidth) * 2 - 1;
                this.sceneManager.mouse.y = -(e.clientY / this.elements.canvas.clientHeight) * 2 + 1;

                // Update the raycaster
                this.sceneManager.raycaster.setFromCamera(this.sceneManager.mouse, this.sceneManager.camera);

                // Calculate objects intersecting the picking ray
                const intersects = this.sceneManager.raycaster.intersectObjects(this.sceneManager.scene.children, true);

                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    // Traverse up in case we hit a child of a group
                    const selectedObject = object.userData.id ? object : this.findParentWithId(object);

                    if (selectedObject && selectedObject.userData.id) {
                        const objectId = selectedObject.userData.id;
                        const multiSelect = e.ctrlKey || e.metaKey;

                        this.selectObjectInScene(objectId, multiSelect);

                        // Update transform controls based on current tool
                        if (this.appState.activeTool !== 'select') {
                            this.sceneManager.transformControls.setMode(this.appState.activeTool);
                            this.sceneManager.transformControls.attach(selectedObject);
                        }
                    }
                } else {
                    // Clicked on empty space - clear selection if not multi-select
                    if (!e.ctrlKey && !e.metaKey) {
                        this.appState.clearSelection();
                        this.sceneManager.clearSelection();
                        this.updateUI();
                    }
                }
            }

            // Helper method to find parent with ID
            findParentWithId(object) {
                let current = object;
                while (current.parent) {
                    if (current.parent.userData && current.parent.userData.id) {
                        return current.parent;
                    }
                    current = current.parent;
                }
                return null;
            }

            handleTransformInputChange() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) return;

                const inputs = this.elements.transformValues.querySelectorAll('input');
                const x = parseFloat(inputs[0].value) || 0;
                const y = parseFloat(inputs[1].value) || 0;
                const z = parseFloat(inputs[2].value) || 0;

                selectedObjects.forEach(obj => {
                    const threeObj = this.sceneManager.getObject(obj.id);
                    if (!threeObj) return;

                    if (this.appState.transformMode === 'location') {
                        threeObj.position.set(x, y, z);
                    } else if (this.appState.transformMode === 'rotation') {
                        threeObj.rotation.set(
                            THREE.MathUtils.degToRad(x),
                            THREE.MathUtils.degToRad(y),
                            THREE.MathUtils.degToRad(z)
                        );
                    } else if (this.appState.transformMode === 'scale') {
                        threeObj.scale.set(x, y, z);
                    }
                });

                this.sceneManager.transformControls.update();
                this.appState.saveHistory(); // Save state after transform
            }

            selectObjectInScene(objectId, multiSelect = false) {
                if (!multiSelect) {
                    this.appState.clearSelection();
                    this.sceneManager.clearSelection();
                }

                this.appState.selectObject(objectId, multiSelect);
                const threeObj = this.sceneManager.getObject(objectId);

                if (threeObj) {
                    if (this.appState.activeTool === 'select') {
                        this.sceneManager.transformControls.detach();
                        this.sceneManager.transformControls.visible = false;
                    } else {
                        this.sceneManager.transformControls.attach(threeObj);
                        this.sceneManager.transformControls.visible = true;
                    }

                    // Update selection box
                    this.sceneManager.selectionBox.setFromObject(threeObj);
                    this.sceneManager.selectionBox.visible = true;
                }
                this.appState.saveHistory();
                this.updateUI();
            }

            createObject(type) {
                const objectData = {
                    id: this.appState.generateId(),
                    type: type,
                    name: `${type}_${this.appState.lastObjectId}`,
                    color: '#808080',
                    roughness: 0.5,
                    metalness: 0,
                    position: { x: 0, y: 0, z: 0 },
                    rotation: { x: 0, y: 0, z: 0 },
                    scale: { x: 1, y: 1, z: 1 }
                };

                // Add to app state first
                this.appState.addObject(objectData);

                // Then add to Three.js scene
                const threeObjWrapper = this.sceneManager.addObject(objectData);
                if (!threeObjWrapper) {
                    console.error('Failed to create object');
                    return;
                }

                // Select the new object
                this.selectObjectInScene(objectData.id);
                this.updateUI();
                this.appState.saveHistory();
                this.showNotification(`${type.charAt(0).toUpperCase() + type.slice(1)} created`, 'success');
            }

            deleteSelectedObjects() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) {
                    this.showNotification('No objects selected', 'warning');
                    return;
                }

                selectedObjects.forEach(obj => {
                    this.appState.removeObject(obj.id);
                    this.sceneManager.removeObject(obj.id);
                });
                this.appState.saveHistory();
                this.updateUI();
                this.showNotification(`${selectedObjects.length} object(s) deleted`, 'success');
            }

            selectAllObjects() {
                this.appState.sceneObjects.forEach(obj => {
                    this.appState.selectObject(obj.id, true);
                });

                if (this.appState.sceneObjects.length > 0) {
                    this.sceneManager.selectObject(this.appState.sceneObjects[0].id);
                }

                this.updateUI();
            }

            groupSelectedObjects() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length < 2) {
                    this.showNotification('Select at least 2 objects to group', 'warning');
                    return;
                }

                const objectIds = selectedObjects.map(obj => obj.id);
                this.appState.groupObjects(objectIds);
                this.showNotification('Objects grouped', 'success');
            }

            ungroupSelectedObjects() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) {
                    this.showNotification('No objects selected', 'warning');
                    return;
                }

                // For simplicity, we'll just ungroup the first selected group
                const group = this.appState.groups.find(g =>
                    selectedObjects.some(obj => obj.id === g.id)
                );

                if (group) {
                    this.appState.ungroupObjects(group.id);
                    this.showNotification('Group ungrouped', 'success');
                } else {
                    this.showNotification('Selected object is not a group', 'warning');
                }
            }

            toggleSelectedObjectsVisibility() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) {
                    this.showNotification('No objects selected', 'warning');
                    return;
                }

                selectedObjects.forEach(obj => {
                    this.appState.toggleObjectVisibility(obj.id);
                    const threeObj = this.sceneManager.getObject(obj.id);
                    if (threeObj) {
                        threeObj.visible = !this.appState.hiddenObjects.includes(obj.id);
                        if (threeObj.userData.helper) {
                            threeObj.userData.helper.visible = !this.appState.hiddenObjects.includes(obj.id);
                        }
                    }
                });

                this.showNotification('Visibility toggled', 'success');
            }

            toggleSelectedObjectsFreeze() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) {
                    this.showNotification('No objects selected', 'warning');
                    return;
                }

                selectedObjects.forEach(obj => {
                    this.appState.toggleObjectFreeze(obj.id);
                    // In a real implementation, you would disable transformation controls for frozen objects
                });

                this.showNotification('Freeze toggled', 'success');
            }

            newProject() {
                if (confirm('Are you sure you want to start a new project? All unsaved changes will be lost.')) {
                    this.appState.resetState();
                    this.sceneManager.scene.children.forEach(child => {
                        if (child !== this.sceneManager.camera &&
                            child !== this.sceneManager.controls &&
                            child !== this.sceneManager.gridHelper &&
                            child !== this.sceneManager.axesHelper &&
                            child !== this.sceneManager.transformControls) {
                            this.sceneManager.scene.remove(child);
                        }
                    });
                    this.updateUI();
                    this.showNotification('New project created', 'success');
                }
            }

            /* exportScene() {
                 const exporter = new THREE.GLTFExporter();
                 exporter.parse(
                     this.sceneManager.scene,
                     (gltf) => {
                         const blob = new Blob([JSON.stringify(gltf)], { type: 'application/json' });
                         const url = URL.createObjectURL(blob);
                         const a = document.createElement('a');
                         a.href = url;
                         a.download = 'scene.gltf';
                         document.body.appendChild(a);
                         a.click();
                         document.body.removeChild(a);
                         URL.revokeObjectURL(url);
                         this.showNotification('Scene exported successfully', 'success');
                     },
                     (error) => {
                         console.error('Export error:', error);
                         this.showNotification('Export failed', 'error');
                     }
                 );
             }*/

            applyTextureToSelected(file) {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) {
                    this.showNotification('No objects selected', 'warning');
                    return;
                }

                const textureType = this.currentTextureType;
                const textureName = file.name;
                const textureUrl = URL.createObjectURL(file);

                // Update UI
                const mapNameElement = document.getElementById(`${textureType}-map-name`);
                if (mapNameElement) {
                    mapNameElement.textContent = textureName;
                }

                // Apply texture to selected objects
                selectedObjects.forEach(obj => {
                    const threeObj = this.sceneManager.getObject(obj.id);
                    if (threeObj && threeObj.material) {
                        this.sceneManager.applyTexture(threeObj, textureType, textureUrl);
                    }
                });

                this.showNotification(`${textureType} texture applied`, 'success');
            }

            clearTexture(textureType) {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) {
                    this.showNotification('No objects selected', 'warning');
                    return;
                }

                // Update UI
                const mapNameElement = document.getElementById(`${textureType}-map-name`);
                if (mapNameElement) {
                    mapNameElement.textContent = 'None';
                }

                // Clear texture from selected objects
                selectedObjects.forEach(obj => {
                    const threeObj = this.sceneManager.getObject(obj.id);
                    if (threeObj && threeObj.material) {
                        switch (textureType) {
                            case 'diffuse':
                                threeObj.material.map = null;
                                break;
                            case 'normal':
                                threeObj.material.normalMap = null;
                                break;
                            case 'roughness':
                                threeObj.material.roughnessMap = null;
                                break;
                        }
                        threeObj.material.needsUpdate = true;
                    }
                });

                this.showNotification(`${textureType} texture cleared`, 'success');
            }

            showNotification(message, type = 'info') {
                const notification = this.elements.notification;
                const notificationMessage = this.elements.notificationMessage;

                notification.className = `notification ${type}`;
                notificationMessage.textContent = message;
                notification.classList.add('show');

                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }

            updateScene() {
                // Remove all objects from Three.js scene that aren't in app state
                const sceneObjectIds = this.appState.sceneObjects.map(obj => obj.id);
                this.sceneManager.scene.children.forEach(child => {
                    if (child.userData && child.userData.id && !sceneObjectIds.includes(child.userData.id)) {
                        this.sceneManager.scene.remove(child);
                        if (child.userData.helper) {
                            this.sceneManager.scene.remove(child.userData.helper);
                        }
                    }
                });

                // Add any objects from app state that aren't in the scene
                this.appState.sceneObjects.forEach(obj => {
                    if (!this.sceneManager.getObject(obj.id)) {
                        this.sceneManager.addObject(obj);
                    }
                });

                // Update selection
                if (this.appState.selectedObjects.length > 0) {
                    this.sceneManager.selectObject(this.appState.selectedObjects[0]);
                } else {
                    this.sceneManager.clearSelection();
                }

                this.updateUI();
            }
        }

        // ==============================================
        // APPLICATION INITIALIZATION
        // ==============================================

        document.addEventListener('DOMContentLoaded', () => {
            try {
                // Initialize application state
                const appState = new AppState();

                // Initialize Three.js scene manager
                const canvas = document.getElementById('three-canvas');
                const sceneManager = new SceneManager(canvas);
                // Link sceneManager to appState
                appState.sceneManager = sceneManager;

                // Initialize UI manager
                const uiManager = new UIManager(appState, sceneManager);
                window.uiManager = uiManager; // Make available globally for debugging

                // Save initial state
                appState.saveHistory();
                let lastTime = 0;
                const targetFPS = 60;
                const frameInterval = 1000 / targetFPS;

                const animate = (time) => {
                    requestAnimationFrame(animate);

                    // Throttle to target FPS
                    const deltaTime = time - lastTime;
                    if (deltaTime < frameInterval) return;

                    lastTime = time - (deltaTime % frameInterval);

                    // Only update controls if needed
                    sceneManager.controls.update();
                    sceneManager.updateTransformControls(); // Add this line
                    // Render scene
                    sceneManager.renderer.render(sceneManager.scene, sceneManager.camera);

                    // Update stats less frequently (once per second)
                    if (time % 1000 < frameInterval) {
                        uiManager.updateStats();
                    }
                };

                requestAnimationFrame(animate);

                // Handle window resize
                window.addEventListener('resize', () => {
                    sceneManager.resize();
                });

                console.log('Olmec initialized successfully');
            } catch (error) {
                console.error('Initialization error:', error);
                alert('Failed to initialize the application. Please check the console for details.');
            }
        });
    </script>
    <!-- At the bottom of the body -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.js"></script>
    <script defer src="https://unpkg.com/vanilla-picker@2"></script>
</body>

</html>